<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2018-11-18 нд 16:49 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Uniform Structured Syntax, Metaprogramming and Run-time Compilation</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Andrey Kotlarski" />
<meta name="description" content="Real world example where uniform syntax enables unthinkable solution"
 />
<meta name="keywords" content="metaprogramming, syntax, lisp, compilation, optimization" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="../css/worg-classic.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="../sitemap.html"> UP </a>
 |
 <a accesskey="H" href="../index.html"> HOME </a>
</div><div id="content">
<h1 class="title">Uniform Structured Syntax, Metaprogramming and Run-time Compilation
<br />
<span class="subtitle">or why you'd be doing yourself disservice not considering Lisp for "big data" processing</span>
</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org01309da">1. Intro</a>
<ul>
<li><a href="#org0ec6d4a">1.1. Too Long, Don't Read</a></li>
</ul>
</li>
<li><a href="#orgdd40940">2. The Problem</a></li>
<li><a href="#org4514b78">3. Approach I - Interpreter</a>
<ul>
<li><a href="#orga9ef750">3.1. WHERE tree</a></li>
<li><a href="#org035028d">3.2. WHERE matcher</a></li>
<li><a href="#org4da3f53">3.3. Clause interpretation</a></li>
</ul>
</li>
<li><a href="#org9a05a26">4. Approach II - Compiler</a>
<ul>
<li><a href="#orgb2632cf">4.1. Prelude</a></li>
<li><a href="#org3cde53f">4.2. Embedded domain specific languages</a></li>
<li><a href="#org245b3b7">4.3. Select implementation</a></li>
<li><a href="#org0434eb9">4.4. Abstracting iteration</a></li>
<li><a href="#orgd81ac55">4.5. Generate WHERE tree</a></li>
<li><a href="#org36dd665">4.6. Transform WHERE clauses</a></li>
<li><a href="#org4b11d40">4.7. Loop unrolling</a></li>
<li><a href="#orgf4b62af">4.8. End result</a></li>
<li><a href="#org31e949e">4.9. Squeezing performance 1</a></li>
<li><a href="#orgbb2bfcc">4.10. Squeezing performance 2</a></li>
<li><a href="#orgd043a43">4.11. Measurements</a></li>
</ul>
</li>
<li><a href="#org8292046">5. Addendum</a>
<ul>
<li><a href="#org2811300">5.1. Manual JIT</a>
<ul>
<li><a href="#orgcd74204">5.1.1. Eval?</a></li>
<li><a href="#org61136b9">5.1.2. Quasi-quotation remark</a></li>
</ul>
</li>
<li><a href="#orgc141078">5.2. Life stages of a program</a></li>
<li><a href="#org3021a61">5.3. Image based development and deploy</a></li>
<li><a href="#org12d6c6f">5.4. Alternative syntax</a></li>
</ul>
</li>
<li><a href="#orgae062fb">6. Further reading</a></li>
</ul>
</div>
</div>

<div id="outline-container-org01309da" class="outline-2">
<h2 id="org01309da"><span class="section-number-2">1</span> Intro</h2>
<div class="outline-text-2" id="text-1">
<p>
Often times I hear the claim that (programming language) syntax
doesn't matter or if it does, it's only to provide some subjective
readability aesthetics.  It's somewhat surprising to me how large
majority of supposedly rational people like programmers/computer
scientists would throw out objectivity with such confidence.  So let
me provide a simple real world case where uniform syntax enables out
of the box solution which is qualitatively simpler.  This is
practically achievable (<a href="https://en.wikipedia.org/wiki/Turing_completeness">Turing-completeness</a> doesn't help much) and
idiomatic in very few languages and about a single one of them has the
additional means and synergy to pull it off with great performance.
</p>
</div>

<div id="outline-container-org0ec6d4a" class="outline-3">
<h3 id="org0ec6d4a"><span class="section-number-3">1.1</span> Too Long, Don't Read</h3>
<div class="outline-text-3" id="text-1-1">
<p>
We develop tiny SQL-like query engine from scratch in <a href="http://lisp-lang.org/">Common
Lisp</a> which performs on par with a cheating C++ version and handily
outruns even more cheating Go version.
</p>

<p>
This is possible because CL compilers are competent, blazing quick and
can be programmatically evoked at runtime over arbitrary just-in-time
generated functions.  This allows turning the task from the usual
run-time interpreter hammering to an even simplified <a href="https://en.wikipedia.org/wiki/Metaprogramming">metaprogramming</a>
march.  Generation and native compilation of specialized for any
concrete query code is deferred right back to query (run) time.  Where
other languages must pre-compile recursive interpreter, CL compiles
down a single if-condition.
</p>

<p>
As for code generation we have the full power of the language plus
whatever we've additionally defined, we show off arguably the most
powerful <a href="https://en.wikipedia.org/wiki/Common_Lisp_Object_System">Common Lisp Object System</a> (CLOS) in use.  This combined with
the fact that generating code in Lisp is isomorphic to writing
"regular" code, makes the solution so simple, concise and elegant,
it's difficult to imagine it does the same thing as those unsung
geniuses writing low-level optimizing compilers in all those powerless
non-Lisp languages.
</p>
</div>
</div>
</div>

<div id="outline-container-orgdd40940" class="outline-2">
<h2 id="orgdd40940"><span class="section-number-2">2</span> The Problem</h2>
<div class="outline-text-2" id="text-2">
<p>
Here's our situation: there are over 100 let's say plain text dbs,
each one containing lines of different fixed-size fields <a href="https://en.wikipedia.org/wiki/ASCII">ASCII</a>
format. Let's assume lines within a single db have same format.
</p>

<pre class="example">
# excerpt from the record S5 db
S5XXZSXX151217999999CBF        X        FLEX CONDITION  
S5YYF021160629999999IBG CY PE081CPETC201PET IN CABIN DOG

# excerpt from the category 1 db
00100030530CNNX0211396626 NRNTR
00100030531CPNX    396627 NRNTR
00100030622UNN   11000000      
</pre>

<p>
So you can consider that each db has a schema where each field is
located at a fixed offset from the beginning of the line.  We have to
provide subset of <a href="https://en.wikipedia.org/wiki/Sql">SQL</a>-like operations over them<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup>, for example:
</p>

<div class="org-src-container">
<pre class="src src-sql"><span style="color: #8ac6f2; font-weight: bold;">SELECT</span> cxr,subcode,commercial_name,date_disc <span style="color: #8ac6f2; font-weight: bold;">FROM</span> recordS5
<span style="color: #8ac6f2; font-weight: bold;">WHERE</span> cxr <span style="color: #8ac6f2; font-weight: bold;">LIKE</span> <span style="color: #95e454;">'YY|XX'</span>
      <span style="color: #8ac6f2; font-weight: bold;">AND</span> ((commercial_name <span style="color: #8ac6f2; font-weight: bold;">LIKE</span> <span style="color: #95e454;">'PET'</span> <span style="color: #8ac6f2; font-weight: bold;">AND</span> <span style="color: #8ac6f2; font-weight: bold;">type</span>=<span style="color: #95e454;">'C'</span>)
          <span style="color: #8ac6f2; font-weight: bold;">OR</span> (<span style="color: #8ac6f2; font-weight: bold;">type</span>=<span style="color: #95e454;">'F'</span> <span style="color: #8ac6f2; font-weight: bold;">AND</span> commercial_name=<span style="color: #95e454;">'MEAL'</span>))
      <span style="color: #8ac6f2; font-weight: bold;">AND</span> date_disc &lt; <span style="color: #95e454;">'180620'</span> <span style="color: #8ac6f2; font-weight: bold;">AND</span> date_eff &lt; date_disc

<span style="color: #8ac6f2; font-weight: bold;">SELECT</span> <span style="color: #e5786d;">COUNT</span>(*) <span style="color: #8ac6f2; font-weight: bold;">FROM</span> category1
<span style="color: #8ac6f2; font-weight: bold;">WHERE</span> age_min &lt;= 28 <span style="color: #8ac6f2; font-weight: bold;">AND</span> 28 &lt;= age_max
      <span style="color: #8ac6f2; font-weight: bold;">AND</span> (tbl_no &lt; <span style="color: #95e454;">'00050000'</span> <span style="color: #8ac6f2; font-weight: bold;">OR</span> tbl_no &gt; <span style="color: #95e454;">'01000000'</span>)
</pre>
</div>

<p>
(cheers if you guess the domain from these, also no, I've never been
affiliated with the well known Lisp company in that sector)
</p>

<p>
We'll have to iterate all db entries, check the WHERE filter over each
line and extract information to be returned in case it passes.  These
queries can happen to run over billions of entries so we'll eye some
"systems" language, band-aids like Python are out of question.
</p>

<p>
Let's focus only on the filter condition.  WHERE is essentially a tree
where intermediate nodes are boolean predicates <b>and</b>, <b>or</b> or <b>not</b>
and leaves being concrete line field operation - comparison, regular
expression matching, either with constant string or other field.
</p>


<div class="figure">
<p><img src="./where.png" alt="where.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org4514b78" class="outline-2">
<h2 id="org4514b78"><span class="section-number-2">3</span> Approach I - Interpreter</h2>
<div class="outline-text-2" id="text-3">
<p>
So how do we go about it?  A straightforward way is to create a tree
structure instance mirroring the WHERE clause and a matcher which
would traverse it for each line to see if the clause is satisfied.
</p>
</div>

<div id="outline-container-orga9ef750" class="outline-3">
<h3 id="orga9ef750"><span class="section-number-3">3.1</span> WHERE tree</h3>
<div class="outline-text-3" id="text-3-1">
<p>
Let's skip over the tedious task of parsing a query and concentrate on
how the WHERE part would be represented for processing:
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #8ac6f2; font-weight: bold;">struct</span> <span style="color: #92a65e; font-weight: bold;">WhereNode</span>
{
<span style="color: #8ac6f2; font-weight: bold;">public</span>:
    <span style="color: #92a65e; font-weight: bold;">OperationType</span> <span style="color: #cae682;">op</span>; <span style="color: #99968b;">// </span><span style="color: #99968b;">and, or, not, regex, stringEq, stringNotEq, stringLess, stringMore...</span>

    <span style="color: #99968b;">// </span><span style="color: #99968b;">not used by and/or/not nodes</span>
    <span style="color: #92a65e; font-weight: bold;">FieldInfo</span> <span style="color: #cae682;">field1</span>;
    <span style="color: #92a65e; font-weight: bold;">FieldInfo</span> <span style="color: #cae682;">field2</span>;           <span style="color: #99968b;">// </span><span style="color: #99968b;">may not be applicable</span>
    <span style="color: #92a65e; font-weight: bold;">size_t</span> <span style="color: #cae682;">cmpSize</span> = 0; <span style="color: #99968b;">// </span><span style="color: #99968b;">comparison length in case of 2 fields, equals the shorter</span>
    <span style="color: #e5786d;">std</span>::<span style="color: #92a65e; font-weight: bold;">string</span> <span style="color: #cae682;">filter</span>;         <span style="color: #99968b;">// </span><span style="color: #99968b;">literal filter if such</span>
    <span style="color: #e5786d;">std</span>::<span style="color: #92a65e; font-weight: bold;">regex</span> <span style="color: #cae682;">regexFilter</span>;     <span style="color: #99968b;">// </span><span style="color: #99968b;">regex literal if such</span>

    <span style="color: #e5786d;">std</span>::<span style="color: #92a65e; font-weight: bold;">vector</span>&lt;<span style="color: #92a65e; font-weight: bold;">WhereNode</span>&gt; <span style="color: #cae682;">children</span>; <span style="color: #99968b;">// </span><span style="color: #99968b;">only and/or/not nodes have children</span>

    <span style="color: #92a65e; font-weight: bold;">bool</span> <span style="color: #cae682;">match</span>(<span style="color: #8ac6f2; font-weight: bold;">const</span> <span style="color: #92a65e; font-weight: bold;">char</span> *<span style="color: #cae682;">line</span>) <span style="color: #8ac6f2; font-weight: bold;">const</span>;

<span style="color: #8ac6f2; font-weight: bold;">private</span>:
    <span style="color: #92a65e; font-weight: bold;">bool</span> <span style="color: #cae682;">applyFieldOp</span>(<span style="color: #8ac6f2; font-weight: bold;">const</span> <span style="color: #92a65e; font-weight: bold;">char</span> *<span style="color: #cae682;">line</span>) <span style="color: #8ac6f2; font-weight: bold;">const</span>;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org035028d" class="outline-3">
<h3 id="org035028d"><span class="section-number-3">3.2</span> WHERE matcher</h3>
<div class="outline-text-3" id="text-3-2">
<p>
Traverses the WHERE tree in <a href="https://en.wikipedia.org/wiki/Depth-first">depth first</a> order and performs
<a href="https://en.wikipedia.org/wiki/Short-circuit_evaluation">short-circuit evaluation</a>:
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #92a65e; font-weight: bold;">bool</span> <span style="color: #e5786d;">WhereNode</span>::<span style="color: #cae682;">match</span>(<span style="color: #8ac6f2; font-weight: bold;">const</span> <span style="color: #92a65e; font-weight: bold;">char</span> *<span style="color: #cae682;">line</span>) <span style="color: #8ac6f2; font-weight: bold;">const</span>
{
    <span style="color: #8ac6f2; font-weight: bold;">switch</span>(op)
    {
    <span style="color: #8ac6f2; font-weight: bold;">case</span> <span style="color: #e5786d;">OperationType</span>::WhereAnd:
    {
        <span style="color: #8ac6f2; font-weight: bold;">for</span>(<span style="color: #8ac6f2; font-weight: bold;">const</span> <span style="color: #8ac6f2; font-weight: bold;">auto</span> &amp;<span style="color: #cae682;">child</span> : children)
        {
            <span style="color: #8ac6f2; font-weight: bold;">if</span>(!child.match(line))
                <span style="color: #8ac6f2; font-weight: bold;">return</span> <span style="color: #e5786d;">false</span>;
        }

        <span style="color: #8ac6f2; font-weight: bold;">return</span> <span style="color: #e5786d;">true</span>;
    }

    <span style="color: #8ac6f2; font-weight: bold;">case</span> <span style="color: #e5786d;">OperationType</span>::WhereOr:
    {
        <span style="color: #8ac6f2; font-weight: bold;">for</span>(<span style="color: #8ac6f2; font-weight: bold;">const</span> <span style="color: #8ac6f2; font-weight: bold;">auto</span> &amp;<span style="color: #cae682;">child</span> : children)
        {
            <span style="color: #8ac6f2; font-weight: bold;">if</span>(child.match(line))
                <span style="color: #8ac6f2; font-weight: bold;">return</span> <span style="color: #e5786d;">true</span>;
        }

        <span style="color: #8ac6f2; font-weight: bold;">return</span> <span style="color: #e5786d;">false</span>;
    }

    <span style="color: #8ac6f2; font-weight: bold;">case</span> <span style="color: #e5786d;">OperationType</span>::WhereNot:
    {
        assert(1 == children.size());
        <span style="color: #8ac6f2; font-weight: bold;">return</span> !children.front().match(line);
    }

    <span style="color: #8ac6f2; font-weight: bold;">default</span>:
        <span style="color: #8ac6f2; font-weight: bold;">return</span> applyFieldOp(line);
    }
}
</pre>
</div>

<p>
If there's one problem with the above, it would probably be that
<b>match</b> is recursive (and not in good <a href="https://en.wikipedia.org/wiki/Tail_recursion">tail-recursive</a> way) so the
compiler wouldn't be that jubilant.  There probably is a way to
linearize the WHERE tree but I'm a little concerned to think out in
depth how to conserve the short-circuiting without backtracking and
getting a headache.
</p>
</div>
</div>

<div id="outline-container-org4da3f53" class="outline-3">
<h3 id="org4da3f53"><span class="section-number-3">3.3</span> Clause interpretation</h3>
<div class="outline-text-3" id="text-3-3">
<p>
For completeness, here's the leaf operation processor:
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #92a65e; font-weight: bold;">bool</span> <span style="color: #e5786d;">WhereNode</span>::<span style="color: #cae682;">applyFieldOp</span>(<span style="color: #8ac6f2; font-weight: bold;">const</span> <span style="color: #92a65e; font-weight: bold;">char</span> *<span style="color: #cae682;">line</span>) <span style="color: #8ac6f2; font-weight: bold;">const</span>
{
    <span style="color: #8ac6f2; font-weight: bold;">switch</span>(op)
    {
    <span style="color: #8ac6f2; font-weight: bold;">case</span> <span style="color: #e5786d;">OperationType</span>::WhereRegex:
        <span style="color: #8ac6f2; font-weight: bold;">if</span>(field2.isEmpty())
        {
            <span style="color: #8ac6f2; font-weight: bold;">return</span> <span style="color: #e5786d;">std</span>::regex_search(line + field1.offset,
                                     line + (field1.offset + field1.size),
                                     regexFilter);
        }
        <span style="color: #8ac6f2; font-weight: bold;">else</span>
        {
            <span style="color: #e5786d;">std</span>::<span style="color: #92a65e; font-weight: bold;">regex</span> <span style="color: #cae682;">lineRegexFilter</span>(line + field2.offset, field2.size);
            <span style="color: #8ac6f2; font-weight: bold;">return</span> <span style="color: #e5786d;">std</span>::regex_search(line + field1.offset,
                                     line + (field1.offset + field1.size),
                                     lineRegexFilter);
        }

    <span style="color: #8ac6f2; font-weight: bold;">case</span> <span style="color: #e5786d;">OperationType</span>::WhereSearch:
        <span style="color: #8ac6f2; font-weight: bold;">return</span> memmem(line + field1.offset, field1.size,
                      filter.c_str(), filter.size());

    <span style="color: #8ac6f2; font-weight: bold;">default</span>:
        <span style="color: #8ac6f2; font-weight: bold;">break</span>;
    }

    <span style="color: #92a65e; font-weight: bold;">int</span> <span style="color: #cae682;">cmpResult</span>;

    <span style="color: #8ac6f2; font-weight: bold;">if</span>(field2.isEmpty())
    {
        cmpResult = memcmp(line + field1.offset, filter.c_str(), filter.size());
    }
    <span style="color: #8ac6f2; font-weight: bold;">else</span>
    {
        cmpResult = memcmp(line + field1.offset, line + field2.offset, cmpSize);
    }

    <span style="color: #8ac6f2; font-weight: bold;">switch</span>(op)
    {
    <span style="color: #8ac6f2; font-weight: bold;">case</span> <span style="color: #e5786d;">OperationType</span>::WhereEq:
        <span style="color: #8ac6f2; font-weight: bold;">return</span> cmpResult == 0;

    <span style="color: #8ac6f2; font-weight: bold;">case</span> <span style="color: #e5786d;">OperationType</span>::WhereNotEq:
        <span style="color: #8ac6f2; font-weight: bold;">return</span> cmpResult != 0;

    <span style="color: #8ac6f2; font-weight: bold;">case</span> <span style="color: #e5786d;">OperationType</span>::WhereLess:
        <span style="color: #8ac6f2; font-weight: bold;">return</span> cmpResult &lt; 0;

    <span style="color: #8ac6f2; font-weight: bold;">case</span> <span style="color: #e5786d;">OperationType</span>::WhereLessEq:
        <span style="color: #8ac6f2; font-weight: bold;">return</span> cmpResult &lt;= 0;

    <span style="color: #8ac6f2; font-weight: bold;">case</span> <span style="color: #e5786d;">OperationType</span>::WhereMore:
        <span style="color: #8ac6f2; font-weight: bold;">return</span> cmpResult &gt; 0;

    <span style="color: #8ac6f2; font-weight: bold;">case</span> <span style="color: #e5786d;">OperationType</span>::WhereMoreEq:
        <span style="color: #8ac6f2; font-weight: bold;">return</span> cmpResult &gt;= 0;
    }

    <span style="color: #8ac6f2; font-weight: bold;">return</span> <span style="color: #e5786d;">false</span>;
}
</pre>
</div>

<p>
We assume certain pre-processing is done while building the tree, like
assigning proper operation type; checking if regex filter is not
really regex, in which case getting downgraded to substring search
etc.
</p>

<p>
For a complete solution we'd need a query parser (or may defer to
something like <a href="https://en.wikipedia.org/wiki/JSON">JSON</a> and use existing parser though that wouldn't be
very ergonomic for interactive use) and another interpreter to
translate and pre-process parsed tokens to the above data structure
used in the hot loop.
</p>
</div>
</div>
</div>

<div id="outline-container-org9a05a26" class="outline-2">
<h2 id="org9a05a26"><span class="section-number-2">4</span> Approach II - Compiler</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-orgb2632cf" class="outline-3">
<h3 id="orgb2632cf"><span class="section-number-3">4.1</span> Prelude</h3>
<div class="outline-text-3" id="text-4-1">
<p>
I actually didn't consider <b>Approach I</b> at all until much later, and
that for educational purposes.  It somehow seems artificial and more
complex than the problem it solves.  I mean, look at the SQL WHERE
clause - it's a boolean expression almost inviting for immediate
evaluation, why do we have to write tree traversal and not "just" use
our language's built-in machinery?
</p>

<p>
Let's lay back and imagine the following scenario from days of yore -
someone comes along and strikes:
</p>

<blockquote>
<p>
<i>Can you extract me this and that field where such and such conditions
are met?  Like in the next hour?  Thankyouverymuch!</i>
</p>
</blockquote>

<p>
What then, one-off program?  I bet in such case you'd write something
quick &amp; dirty, morally equivalent to:
</p>

<div class="org-src-container">
<pre class="src src-c++"><span style="color: #8ac6f2; font-weight: bold;">const</span> <span style="color: #e5786d;">std</span>::<span style="color: #92a65e; font-weight: bold;">regex</span> <span style="color: #cae682;">cxrRegex</span>(<span style="color: #95e454;">"YY|XX"</span>);
<span style="color: #8ac6f2; font-weight: bold;">const</span> <span style="color: #e5786d;">std</span>::<span style="color: #92a65e; font-weight: bold;">string</span> <span style="color: #cae682;">commercialNameRegex</span>(<span style="color: #95e454;">"PET"</span>);

<span style="color: #92a65e; font-weight: bold;">bool</span> <span style="color: #cae682;">match</span>(<span style="color: #8ac6f2; font-weight: bold;">const</span> <span style="color: #92a65e; font-weight: bold;">char</span> *<span style="color: #cae682;">line</span>)
{
    <span style="color: #8ac6f2; font-weight: bold;">return</span> (<span style="color: #e5786d;">std</span>::regex_search(line + CXR_OFFSET, line + (CXR_OFFSET + CXR_SIZE), cxrRegex)
            &amp;&amp; ((memmem(line + COMMERCIAL_NAME_OFFSET, COMMERCIAL_NAME_SIZE,
                        commercialNameRegex.c_str(), commercialNameRegex.size())
                 &amp;&amp; line[TYPE_OFFSET] == <span style="color: #95e454;">'C'</span>)
                || (line[TYPE_OFFSET] == <span style="color: #95e454;">'F'</span>
                    &amp;&amp; memcmp(<span style="color: #95e454;">"MEAL"</span>, line + COMMERCIAL_NAME_OFFSET, <span style="color: #8ac6f2; font-weight: bold;">sizeof</span>(<span style="color: #95e454;">"MEAL"</span>) - 1) == 0))
            &amp;&amp; memcmp(<span style="color: #95e454;">"180620"</span>, line + DATE_DISC_OFFSET, DATE_DISC_SIZE) &lt; 0
            &amp;&amp; memcmp(line + DATE_EFF_OFFSET, line + DATE_DISC_OFFSET, DATE_DISC_SIZE) &lt; 0);
}
</pre>
</div>

<p>
Which is about as simple and efficient (save for some clause
reordering that can be done in order to push cheaper checks earlier)
as one can get.  No recursion, no switches, no loops.  Some contrast
to the general solution!  Ignoring syntax noise, this is direct
translation of the WHERE condition.
</p>

<p>
Now imagine if on receiving a query we could temporarily pause time,
write a simple and efficient matcher tailored to the specific query,
compile and then let it fly over the db.  And remember to unpause
cosmic time of course!  We can dream, or&#x2026;
</p>
</div>
</div>

<div id="outline-container-org3cde53f" class="outline-3">
<h3 id="org3cde53f"><span class="section-number-3">4.2</span> Embedded domain specific languages</h3>
<div class="outline-text-3" id="text-4-2">
<p>
By the way did you notice how ugly the one-off thing looks?  All those
parenthesis&#x2026;  We declared interest only in "systems" languages but
let's see how we'd approach this problem from <a href="http://lisp-lang.org/">Common Lisp</a>'s
side<sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup>.
</p>

<p>
The usual thing to do is embed a <a href="https://en.wikipedia.org/wiki/Domain-specific_language">DSL</a>.  We can represent the selection
example like this:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(select (cxr subcode commercial_name date_disc) recordS5
        <span style="color: #e5786d;">:where</span> (and (like cxr <span style="color: #95e454;">"YY|XX"</span>)
                    (or (and (like COMMERCIAL_NAME <span style="color: #95e454;">"PET"</span>)
                             (= type <span style="color: #95e454;">"C"</span>))
                        (and (= type <span style="color: #95e454;">"F"</span>)
                             (= commercial_name <span style="color: #95e454;">"MEAL"</span>)))
                    (&lt; <span style="color: #95e454;">"180620"</span> date_disc)
                    (&lt; date_eff date_disc)))
</pre>
</div>

<p>
Don't know about you, but on my eyes this looks better than SQL's
supposed to be humane syntax.  A recurring theme in Lisp eDSL
programming is that one first chooses nice succinct <a href="https://en.wikipedia.org/wiki/S-expressions">S-expression</a>
representation (leaving all parsing to the <a href="http://www.lispworks.com/documentation/HyperSpec/Body/02_b.htm">Lisp reader</a>) and then is
confident that will be able to transform it to whatever executable
code is needed.  We can of course implement <b>Approach I</b> now.  But we
can do better.  Much better!
</p>
</div>
</div>

<div id="outline-container-org245b3b7" class="outline-3">
<h3 id="org245b3b7"><span class="section-number-3">4.3</span> Select implementation</h3>
<div class="outline-text-3" id="text-4-3">
<p>
So <b>select</b> has to be <a href="http://www.gigamonkeys.com/book/macros-defining-your-own.html">macro</a> (the chosen representation doesn't adhere
to the function calling convention, for user convenience) which
expands to procedure that maps over the given db, <span class="underline">compiles</span> (CL
compilers are lightening fast) and then calls it.  Note that during
its macro expansion, it will be observing a concrete query so it can
check out the db and its schema, what fields are selected, what is the
exact WHERE clause.  Instead of solving the problem for <span class="underline">all</span> possible
queries as <b>Approach I</b> <span class="underline">must</span>, we <span class="underline">can</span> instead solve for this single
case.  That's our time pausing mechanism.
</p>

<p>
Since we are supposed to work over large dbs, we can gain a lot by
first introspecting the request and specializing on its
properties<sup><a id="fnr.3" class="footref" href="#fn.3">3</a></sup>.  So let's make a little impromptu <a href="https://en.wikipedia.org/wiki/Optimizing_compiler">optimizing
compiler</a>!  Don't freak out, it's surprisingly easy&#x2026; in Lisp:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #8ac6f2; font-weight: bold;">defmacro</span> <span style="color: #cae682;">select</span> (field-list db <span style="color: #92a65e; font-weight: bold;">&amp;key</span> where)
  <span style="color: #95e454;">"Generate selection procedure and run it."</span>
  (<span style="color: #8ac6f2; font-weight: bold;">let</span> ((spec (get-spec db)))  <span style="color: #99968b;">;pull out the specification for this db</span>
    `(funcall (compile nil (<span style="color: #8ac6f2; font-weight: bold;">lambda</span> ()  <span style="color: #99968b;">;guarantee execution of a compiled object</span>
                             (<span style="color: #8ac6f2; font-weight: bold;">declare</span> (optimize (speed 3) (debug 0) (safety 1) (space 0)))
                             (do-lines (line ,spec) <span style="color: #99968b;">;bind line to db entries</span>
                               <span style="color: #99968b;">;; </span><span style="color: #99968b;">if where is empty, condition is considered always satisfied</span>
                               (<span style="color: #8ac6f2; font-weight: bold;">when</span> ,(or (gen-where where 'line spec) t)
                                 ,(gen-print-selection field-list 'line spec))))))))
</pre>
</div>

<p>
Here <a href="#org0434eb9">do-lines</a> would be a macro that abstracts iteration over db
entries.  <b>spec</b> is for example structure/object instance which holds
information about specific db - storage (file), entry size, field
names with their offsets and sizes.  I won't spell it out, you can
imagine what methods working over it would do.
</p>

<p>
Result wise we can get away only with the body of the procedure
enclosed by <a href="#org0434eb9">do-lines</a> but depending on lisp implementation, this might
get executed in interpreter mode<sup><a id="fnr.4" class="footref" href="#fn.4">4</a></sup>.  However, in this case we want
to explicitly ensure compilation happens.
</p>
</div>
</div>

<div id="outline-container-org0434eb9" class="outline-3">
<h3 id="org0434eb9"><span class="section-number-3">4.4</span> Abstracting iteration</h3>
<div class="outline-text-3" id="text-4-4">
<p>
As a lyrical deviation, here's how we can implement iteration for our
example flat file db representation:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #8ac6f2; font-weight: bold;">defmacro</span> <span style="color: #cae682;">do-lines</span> ((line-var spec) <span style="color: #92a65e; font-weight: bold;">&amp;body</span> body)
  <span style="color: #95e454;">"Bind LINE-VAR to each line in SPEC specified file and execute BODY."</span>
  (<span style="color: #8ac6f2; font-weight: bold;">let</span> ((ins (gensym)) <span style="color: #99968b;">;make sure the file stream variable is not visible to the body</span>
        (line-size (1+ (spec-size spec)))) <span style="color: #99968b;">;line size is known, add 1 for newline</span>
    `(<span style="color: #8ac6f2; font-weight: bold;">let</span> ((,line-var (make-string ,line-size <span style="color: #e5786d;">:element-type</span> 'base-char)))<span style="color: #99968b;">;allocate line buffer</span>
       (<span style="color: #8ac6f2; font-weight: bold;">declare</span> (type (simple-base-string ,line-size) ,line-var)
                (dynamic-extent ,line-var)) <span style="color: #99968b;">;use stack allocation if possible</span>
       (<span style="color: #8ac6f2; font-weight: bold;">with-open-file</span> (,ins ,(spec-path spec) <span style="color: #e5786d;">:direction</span> <span style="color: #e5786d;">:input</span>
                                               <span style="color: #e5786d;">:external-format</span> <span style="color: #e5786d;">:ascii</span>
                                               <span style="color: #e5786d;">:element-type</span> 'base-char)
         (<span style="color: #8ac6f2; font-weight: bold;">loop</span> while (= ,line-size (read-sequence ,line-var ,ins))
               do ,@body)))))
</pre>
</div>

<p>
See, that's what it takes to provide convenient zero cost syntactic
abstraction for specialized file line iteration in spirit of the
built-in <a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_dolist.htm">dolist</a>.  No need to hack the compiler, pray to <a href="https://en.wikipedia.org/wiki/BDFL">BDFL</a> and/or
assemble language committee for agreement.
</p>

<p>
Since entry size for particular db is fixed and known, we declare (the
compiler might infer this type on its own without the declaration) and
pre-allocate appropriately typed and sized line buffer and read
entries within it.  The declaration may further help the compiler
elide array bound checks for the enclosed line operations.<sup><a id="fnr.5" class="footref" href="#fn.5">5</a></sup>
</p>

<p>
I didn't name this <b>do-file-lines</b> because it can be extended to handle
other db storage types, key-value, SQL, whatever.  This is the place
to extend if we go for parallel processing too.
</p>
</div>
</div>

<div id="outline-container-orgd81ac55" class="outline-3">
<h3 id="orgd81ac55"><span class="section-number-3">4.5</span> Generate WHERE tree</h3>
<div class="outline-text-3" id="text-4-5">
<p>
Let's look at the WHERE transformation.  We can mirror the query tree
and replace necessary parts (the leaves in this case) with "real"
code:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #8ac6f2; font-weight: bold;">defun</span> <span style="color: #cae682;">gen-where</span> (where line-var spec)
  <span style="color: #95e454;">"Create actual boolean tree for WHERE.</span>
<span style="color: #95e454;">LINE-VAR is symbol representing the current line variable.</span>
<span style="color: #95e454;">SPEC contains fields' offset and size information."</span>
  (<span style="color: #8ac6f2; font-weight: bold;">when</span> (consp where)
    (<span style="color: #8ac6f2; font-weight: bold;">let</span> ((op (first where)))
      (<span style="color: #8ac6f2; font-weight: bold;">cond</span> ((consp op)         <span style="color: #99968b;">;several expressions in a row, recurse</span>
             (cons (gen-where op line-var spec)
                   (gen-where (rest where) line-var spec)))
            ((member op '(and or not))  <span style="color: #99968b;">;intermediate node, recurse</span>
             (cons op (gen-where (rest where) line-var spec)))
            ((member op '(= /= &lt; &lt;= &gt; &gt;= like)) <span style="color: #99968b;">;leaf</span>
             (gen-field-op where line-var spec))
            (t (<span style="color: #ccaa8f;">error</span> (format nil <span style="color: #95e454;">"Bad where clause: ~A"</span> where)))))))
</pre>
</div>

<p>
Where <a href="#org36dd665">gen-field-op</a> based on the field operation, fields and constants
involved and given the specification for field offsets and sizes would
generate appropriate code.
</p>

<p>
Amusingly this miniscule recursive, let's say <a href="https://en.wikipedia.org/wiki/Source-to-source_compiler">transpiler</a>, corresponds
to the recursive <a href="#org035028d">match</a> procedure in the <b>Approach I</b> solution.  Only
the former solves the problem partly at compile-time (<a href="#orgc141078">macro expansion
time</a> if we have to be pedantic) and eliminates run-time recursion,
while the latter is confined to roar only at run-time.
</p>
</div>
</div>

<div id="outline-container-org36dd665" class="outline-3">
<h3 id="org36dd665"><span class="section-number-3">4.6</span> Transform WHERE clauses</h3>
<div class="outline-text-3" id="text-4-6">
<p>
As a little preparation for clause transformers, let's introduce some
helpers:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #8ac6f2; font-weight: bold;">defclass</span> <span style="color: #92a65e; font-weight: bold;">operand-traits</span> ()
  ((offset <span style="color: #e5786d;">:initarg</span> <span style="color: #e5786d;">:offset</span>)
   (size <span style="color: #e5786d;">:initarg</span> <span style="color: #e5786d;">:size</span>)
   (filter <span style="color: #e5786d;">:initarg</span> <span style="color: #e5786d;">:filter</span> <span style="color: #e5786d;">:initform</span> nil)))

(<span style="color: #8ac6f2; font-weight: bold;">defmethod</span> <span style="color: #cae682;">get-operand-traits</span> ((operand string) spec)
  <span style="color: #95e454;">"Get dimensions of literal string OPERAND."</span>
  (<span style="color: #8ac6f2; font-weight: bold;">declare</span> (ignore spec))
  (make-instance 'operand-traits <span style="color: #e5786d;">:offset</span> 0 <span style="color: #e5786d;">:size</span> (length operand)
                                 <span style="color: #e5786d;">:filter</span> operand))

(<span style="color: #8ac6f2; font-weight: bold;">defmethod</span> <span style="color: #cae682;">get-operand-traits</span> ((operand symbol) spec)
  <span style="color: #95e454;">"Get dimensions of field OPERAND according to SPEC."</span>
  (make-instance 'operand-traits <span style="color: #e5786d;">:offset</span> (field-offset operand spec)
                                 <span style="color: #e5786d;">:size</span> (field-size operand spec)))
</pre>
</div>

<p>
Above we introduce a class to represent both field references and
constant string operands and (an implicit) <a href="http://www.gigamonkeys.com/book/object-reorientation-generic-functions.html">generic function</a> with
couple of methods to dispatch the 2 cases.  Here come the actual
generators:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #8ac6f2; font-weight: bold;">defun</span> <span style="color: #cae682;">gen-field-op</span> (clause line-var spec)
  <span style="color: #95e454;">"Generate code for a leaf where CLAUSE."</span>
  (<span style="color: #8ac6f2; font-weight: bold;">destructuring-bind</span> (op field1 field2) clause <span style="color: #99968b;">;decompose clause</span>
    (gen-field-clause op (get-operand-traits field1 spec)
                      (get-operand-traits field2 spec) line-var)))

(<span style="color: #8ac6f2; font-weight: bold;">defun</span> <span style="color: #cae682;">simple-regex?</span> (str)
  <span style="color: #95e454;">"Check if string is not really a regex.</span>
<span style="color: #95e454;">This a bit pessimistic."</span>
  (not (find-if-not #'alphanumericp str)))

(<span style="color: #8ac6f2; font-weight: bold;">defmethod</span> <span style="color: #cae682;">gen-field-clause</span> ((op (eql 'like)) field1 field2 line-var)
  <span style="color: #95e454;">"Generate code for regex clause."</span>
  (<span style="color: #8ac6f2; font-weight: bold;">with-slots</span> ((offset1 offset) (size1 size)) field1
    (<span style="color: #8ac6f2; font-weight: bold;">with-slots</span> ((offset2 offset) (size2 size) (filter2 filter)) field2
      (<span style="color: #8ac6f2; font-weight: bold;">cond</span> ((null filter2)             <span style="color: #99968b;">;regex is taken from a field</span>
             `(cl-ppcre:scan (subseq ,line-var ,offset2
                                     <span style="color: #e5786d;">:end</span> ,(+ offset2 size2))
                             ,line-var <span style="color: #e5786d;">:start</span> ,offset1
                                       <span style="color: #e5786d;">:end</span> ,(+ offset1 size1)))
            ((simple-regex? filter2) <span style="color: #99968b;">;use plain search instead of regex</span>
             `(search ,filter2 ,line-var
                      <span style="color: #e5786d;">:start1</span> ,offset2 <span style="color: #e5786d;">:end1</span> ,(+ offset2 size2)
                      <span style="color: #e5786d;">:start2</span> ,offset1 <span style="color: #e5786d;">:end2</span> ,(+ offset1 size1)))
            (t `(cl-ppcre:scan ,filter2
                               ,line-var <span style="color: #e5786d;">:start</span> ,offset1
                                         <span style="color: #e5786d;">:end</span> ,(+ offset1 size1)))))))

(<span style="color: #8ac6f2; font-weight: bold;">defun</span> <span style="color: #cae682;">translate-op</span> (op <span style="color: #92a65e; font-weight: bold;">&amp;optional</span> char?)
  <span style="color: #95e454;">"Return string/char operation corresponding to OP."</span>
  (intern (concatenate 'string (<span style="color: #8ac6f2; font-weight: bold;">if</span> char? <span style="color: #95e454;">"CHAR"</span> <span style="color: #95e454;">"STRING"</span>)
                       (symbol-name op))))

(<span style="color: #8ac6f2; font-weight: bold;">defmethod</span> <span style="color: #cae682;">gen-field-clause</span> (op field1 field2 line-var)
  <span style="color: #95e454;">"Generate code for a comparison clause."</span>
  (<span style="color: #8ac6f2; font-weight: bold;">with-slots</span> ((offset1 offset) (size1 size) (filter1 filter)) field1
    (<span style="color: #8ac6f2; font-weight: bold;">with-slots</span> ((offset2 offset) (size2 size) (filter2 filter)) field2
      (<span style="color: #8ac6f2; font-weight: bold;">let</span> ((size (min size1 size2)))
        (<span style="color: #8ac6f2; font-weight: bold;">if</span> (= 1 size)           <span style="color: #99968b;">;optimize single character comparison</span>
            (list (translate-op op t)
                  (<span style="color: #8ac6f2; font-weight: bold;">if</span> filter1           <span style="color: #99968b;">;string literal?</span>
                      (aref filter1 0)
                      `(aref ,line-var ,offset1))
                  (<span style="color: #8ac6f2; font-weight: bold;">if</span> filter2
                      (aref filter2 0)
                      `(aref ,line-var ,offset2)))
            (list (translate-op op)
                  (or filter1 line-var) (or filter2 line-var)
                  <span style="color: #e5786d;">:start1</span> offset1 <span style="color: #e5786d;">:end1</span> (+ offset1 size)
                  <span style="color: #e5786d;">:start2</span> offset2 <span style="color: #e5786d;">:end2</span> (+ offset2 size)))))))
</pre>
</div>

<p>
Again (an implicit) generic function through a couple of methods helps
us differentiate between the regex matching and plain comparisons.
Here's how the expanded WHERE part of the code will look like for our
example:
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #99968b;">;; </span><span style="color: #99968b;">bellow :ENDs are actually already folded constants</span>
(AND (CL-PPCRE:SCAN <span style="color: #95e454;">"YY|XX"</span> LINE <span style="color: #e5786d;">:START</span> CXR-OFFSET <span style="color: #e5786d;">:END</span> (+ CXR-OFFSET CXR-SIZE))
     (OR               <span style="color: #99968b;">;we can detect that "PET" is not really a regex</span>
      (AND (SEARCH <span style="color: #95e454;">"PET"</span> LINE <span style="color: #e5786d;">:START1</span> 0 <span style="color: #e5786d;">:END1</span> 3 <span style="color: #99968b;">;and use plain search instead</span>
                              <span style="color: #e5786d;">:START2</span> COMMERCIAL_NAME-OFFSET
                              <span style="color: #e5786d;">:END2</span> (+ COMMERCIAL_NAME-OFFSET COMMERCIAL_NAME-SIZE))
           (CHAR= (AREF LINE TYPE-OFFSET) #\C)) <span style="color: #99968b;">;specialize size 1 comparisons</span>
      (AND
       (CHAR= (AREF LINE TYPE-OFFSET) #\F)
       (STRING= <span style="color: #95e454;">"MEAL"</span> LINE <span style="color: #e5786d;">:START1</span> 0 <span style="color: #e5786d;">:END1</span> 4
                            <span style="color: #e5786d;">:START2</span> COMMERCIAL_NAME-OFFSET <span style="color: #e5786d;">:END2</span> (+ COMMERCIAL_NAME-OFFSET 4))))
     (STRING&lt; <span style="color: #95e454;">"180620"</span> LINE <span style="color: #e5786d;">:START1</span> 0 <span style="color: #e5786d;">:END1</span> 6
                            <span style="color: #e5786d;">:START2</span> DATE_DISC-OFFSET <span style="color: #e5786d;">:END2</span> (+ DATE_DISC-OFFSET 6))
     (STRING&lt; LINE LINE <span style="color: #e5786d;">:START1</span> DATE_EFF-OFFSET <span style="color: #e5786d;">:END1</span> (+ DATE_EFF-OFFSET DATE_EFF-SIZE)
                        <span style="color: #e5786d;">:START2</span> DATE_DISC-OFFSET <span style="color: #e5786d;">:END2</span> (+ DATE_DISC-OFFSET DATE_DISC-SIZE)))
</pre>
</div>

<p>
Beside more readable, that's analogical to the C++ <a href="#orgb2632cf">one-off version</a>.
From such base, we can apply other transformations like
result-preserving <a href="https://en.wikipedia.org/wiki/Boolean_algebra">boolean algebra</a> or just reordering.
</p>
</div>
</div>

<div id="outline-container-org4b11d40" class="outline-3">
<h3 id="org4b11d40"><span class="section-number-3">4.7</span> Loop unrolling</h3>
<div class="outline-text-3" id="text-4-7">
<p>
While the WHERE simplification is most substantial, other parts of the
selection procedure can also enjoy improvement.  Concretely, under
<b>Approach I</b> one has to introduce cycle over the selected fields to
print them.  We can do this of course but <b>Approach II</b> allows such
loop to be unrolled during the <a href="#orgc141078">macro expansion phase</a>.  Why do this?
</p>

<p>
Because we can!  More responsibly, combined with the above line size
declaration, the compiler (if not sufficiently advanced to unroll on
its own) will now be certain that all line operations are within array
bounds.  And will open opportunity for other optimizations.  Here's
how to do it:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #8ac6f2; font-weight: bold;">defun</span> <span style="color: #cae682;">gen-print-selection</span> (fields line-var spec)
  <span style="color: #95e454;">"Unroll selected FIELDS' print statements.</span>
<span style="color: #95e454;">LINE-VAR is symbol representing the current line variable.</span>
<span style="color: #95e454;">SPEC holds field offset details."</span>
  `(<span style="color: #8ac6f2; font-weight: bold;">progn</span>
     ,@(<span style="color: #8ac6f2; font-weight: bold;">loop</span> for field in fields <span style="color: #99968b;">;collect print statements in list and splice them</span>
             collect `(write-string ,line-var nil
                                    <span style="color: #e5786d;">:start</span> ,(field-offset field spec)
                                    <span style="color: #e5786d;">:end</span> ,(+ (field-offset field spec) <span style="color: #99968b;">;constant fold</span>
                                             (field-size field spec))))
     (format t <span style="color: #95e454;">"~%"</span>)))                  <span style="color: #99968b;">;newline</span>
</pre>
</div>

<p>
Which will expand to:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #8ac6f2; font-weight: bold;">PROGN</span>
  (WRITE-STRING LINE NIL
                <span style="color: #e5786d;">:START</span> CXR-OFFSET
                <span style="color: #e5786d;">:END</span> (+ CXR-OFFSET CXR-SIZE)) <span style="color: #99968b;">;these will actually be already summed numbers</span>
  (WRITE-STRING LINE NIL <span style="color: #99968b;">;not that the compiler wouldn't constant fold them anyway</span>
                <span style="color: #e5786d;">:START</span> SUBCODE-OFFSET
                <span style="color: #e5786d;">:END</span> (+ SUBCODE-OFFSET SUBCODE-SIZE))
  (WRITE-STRING LINE NIL
                <span style="color: #e5786d;">:START</span> COMMERCIAL_NAME-OFFSET
                <span style="color: #e5786d;">:END</span> (+ COMMERCIAL_NAME-OFFSET COMMERCIAL_NAME-SIZE))
  (WRITE-STRING LINE NIL
                <span style="color: #e5786d;">:START</span> DATE_DISC-OFFSET
                <span style="color: #e5786d;">:END</span> (+ DATE_DISC-OFFSET DATE_DISC-SIZE))
  (FORMAT T <span style="color: #95e454;">"~%"</span>))
</pre>
</div>

<p>
We can check if adjacent in the schema fields are selected next to
each other and fold them within single <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_wr_stg.htm">write-string</a> call.  We can also
unroll just some fields and leave a loop for the rest if too many, not
to blow executable size.  We are trying to help the compiler generate
good code while the compiler is helping us generate good code.  <a href="https://en.wikipedia.org/wiki/Drawing_Hands">Escher</a>
would approve.
</p>
</div>
</div>

<div id="outline-container-orgf4b62af" class="outline-3">
<h3 id="orgf4b62af"><span class="section-number-3">4.8</span> End result</h3>
<div class="outline-text-3" id="text-4-8">
<p>
Congratulations, we just made a working file query engine<sup><a id="fnr.6" class="footref" href="#fn.6">6</a></sup>!  We
designed a nice query language, outsourced all parsing to the <a href="http://www.lispworks.com/documentation/HyperSpec/Body/02_b.htm">Lisp
reader</a>, courageously went onto implementing a <a href="https://en.wikipedia.org/wiki/One-pass_compiler">one-pass</a> to source
compiler (which in this case is easier than <a href="https://en.wikipedia.org/wiki/Interpreter_(computing)">interpreter</a>!) and even
managed to sprinkle some optimizations.  And on top of that, the
language implementation borrowed us its "real" compiler (at run-time!)
to optimize the expansion and generate machine code.
</p>

<p>
Let's assume Record S5 has fixed size of 56 bytes and field offsets
and sizes:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">field</th>
<th scope="col" class="org-right">offset</th>
<th scope="col" class="org-right">size</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">cxr</td>
<td class="org-right">2</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">type</td>
<td class="org-right">4</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">subcode</td>
<td class="org-right">5</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-left"><code>date_eff</code></td>
<td class="org-right">8</td>
<td class="org-right">6</td>
</tr>

<tr>
<td class="org-left"><code>date_disc</code></td>
<td class="org-right">14</td>
<td class="org-right">6</td>
</tr>

<tr>
<td class="org-left"><code>commercial_name</code></td>
<td class="org-right">40</td>
<td class="org-right">16</td>
</tr>
</tbody>
</table>

<p>
We can enjoy the total of our efforts using <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_mexp_.htm">macroexpand</a> in the <a href="https://en.wikipedia.org/wiki/REPL">REPL</a>:
</p>

<div class="org-src-container">
<pre class="src src-lisp">CL-USER&gt; (macroexpand '(select (cxr subcode commercial_name date_disc) recordS5
                               <span style="color: #e5786d;">:where</span> (and (like cxr <span style="color: #95e454;">"YY|XX"</span>)
                                           (or (and (like COMMERCIAL_NAME <span style="color: #95e454;">"PET"</span>)
                                                (= type <span style="color: #95e454;">"C"</span>))
                                               (and (= type <span style="color: #95e454;">"F"</span>)
                                                    (= commercial_name <span style="color: #95e454;">"MEAL"</span>)))
                                           (&lt; <span style="color: #95e454;">"180620"</span> date_disc)
                                           (&lt; date_eff date_disc))))
(FUNCALL
 (COMPILE NIL
          (<span style="color: #8ac6f2; font-weight: bold;">LAMBDA</span> ()
            (<span style="color: #8ac6f2; font-weight: bold;">DECLARE</span> (OPTIMIZE (SPEED 3) (DEBUG 0) (SAFETY 1) (SPACE 0)))
            (<span style="color: #8ac6f2; font-weight: bold;">LET</span> ((LINE (MAKE-STRING 57 <span style="color: #e5786d;">:ELEMENT-TYPE</span> 'BASE-CHAR)))
              (<span style="color: #8ac6f2; font-weight: bold;">DECLARE</span> (TYPE (SIMPLE-BASE-STRING 57) LINE)
                       (DYNAMIC-EXTENT LINE))
              (<span style="color: #8ac6f2; font-weight: bold;">WITH-OPEN-FILE</span> (#<span style="color: #e5786d;">:G616</span> #P<span style="color: #95e454;">"/path/to/recordS5.db"</span> <span style="color: #e5786d;">:DIRECTION</span> <span style="color: #e5786d;">:INPUT</span>
                                                               <span style="color: #e5786d;">:EXTERNAL-FORMAT</span> <span style="color: #e5786d;">:ASCII</span>
                                                               <span style="color: #e5786d;">:ELEMENT-TYPE</span> 'BASE-CHAR)
                (<span style="color: #8ac6f2; font-weight: bold;">LOOP</span> WHILE (= 57 (READ-SEQUENCE LINE #<span style="color: #e5786d;">:G616</span>))
                      DO (<span style="color: #8ac6f2; font-weight: bold;">WHEN</span>
                             (AND (CL-PPCRE:SCAN <span style="color: #95e454;">"YY|XX"</span> LINE <span style="color: #e5786d;">:START</span> 2 <span style="color: #e5786d;">:END</span> 4)
                                  (OR
                                   (AND (SEARCH <span style="color: #95e454;">"PET"</span> LINE <span style="color: #e5786d;">:START1</span> 0 <span style="color: #e5786d;">:END1</span> 3
                                                           <span style="color: #e5786d;">:START2</span> 40 <span style="color: #e5786d;">:END2</span> 56)
                                        (CHAR= (AREF LINE 7) #\C))
                                   (AND (CHAR= (AREF LINE 7) #\F)
                                        (STRING= <span style="color: #95e454;">"MEAL"</span> LINE <span style="color: #e5786d;">:START1</span> 0 <span style="color: #e5786d;">:END1</span> 4
                                                             <span style="color: #e5786d;">:START2</span> 40 <span style="color: #e5786d;">:END2</span> 44)))
                                  (STRING&lt; <span style="color: #95e454;">"180620"</span> LINE <span style="color: #e5786d;">:START1</span> 0 <span style="color: #e5786d;">:END1</span> 6
                                                         <span style="color: #e5786d;">:START2</span> 14 <span style="color: #e5786d;">:END2</span> 20)
                                  (STRING&lt; LINE LINE <span style="color: #e5786d;">:START1</span> 8 <span style="color: #e5786d;">:END1</span> 14 <span style="color: #e5786d;">:START2</span> 14
                                                     <span style="color: #e5786d;">:END2</span> 20))
                           (<span style="color: #8ac6f2; font-weight: bold;">PROGN</span>
                             (WRITE-STRING LINE NIL <span style="color: #e5786d;">:START</span> 2 <span style="color: #e5786d;">:END</span> 4)
                             (WRITE-STRING LINE NIL <span style="color: #e5786d;">:START</span> 5 <span style="color: #e5786d;">:END</span> 8)
                             (WRITE-STRING LINE NIL <span style="color: #e5786d;">:START</span> 40 <span style="color: #e5786d;">:END</span> 56)
                             (WRITE-STRING LINE NIL <span style="color: #e5786d;">:START</span> 14 <span style="color: #e5786d;">:END</span> 20)
                             (FORMAT T <span style="color: #95e454;">"~%"</span>)))))))))
</pre>
</div>

<p>
Which is about what one would write by hand if not lazy to unroll
loops&#x2026;and not afraid of magic constants.  And nice starting point
for the compiler to generate machine code before running it over the
db.
</p>

<p>
In fact, in similar vein the <a href="https://edicl.github.io/cl-ppcre/">cl-ppcre</a> library used here goes a step
further than usual compiled languages to build regex <a href="https://en.wikipedia.org/wiki/Deterministic_finite_automaton">state machine</a>
scanners for constant literals (as is the case in our expansion) at
compile-time thanks to a <a href="#orgc141078">compiler macro</a>.  I hear people are still
struggling to <a href="https://github.com/hanickadot/compile-time-regular-expressions">hack limited form of this</a> with templates in C++?
</p>
</div>
</div>

<div id="outline-container-org31e949e" class="outline-3">
<h3 id="org31e949e"><span class="section-number-3">4.9</span> Squeezing performance 1</h3>
<div class="outline-text-3" id="text-4-9">
<p>
With such simple, straightforward code and few declarations, the
superb <a href="http://sbcl.org/">Steel Bank Common Lisp</a> compiler in particular would be able to
do respectable job.  But performance in this case will still be 4-5
times slower than competent C++ version for the following prosaic
differences:
</p>

<ul class="org-ul">
<li>there's no buffering on file read while our entries may be quite
small</li>
<li>the operations we use require string types which are not direct
representation of the file bytes, thus <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_rd_seq.htm">read-sequence</a> has to apply
conversion</li>
</ul>

<p>
The first requires adjusting only the <a href="#org0434eb9">do-lines</a> macro:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #8ac6f2; font-weight: bold;">defconstant</span> <span style="color: #cae682;">+max-buffer-size+</span> (* 1024 6)
  <span style="color: #95e454;">"Max chunk size to preload in bytes."</span>)

(<span style="color: #8ac6f2; font-weight: bold;">deftype</span> <span style="color: #92a65e; font-weight: bold;">ub-char</span> () '(unsigned-byte 8)) <span style="color: #99968b;">;read file data in raw bytes because faster</span>

(<span style="color: #8ac6f2; font-weight: bold;">defmacro</span> <span style="color: #cae682;">do-lines</span> ((line-var spec) <span style="color: #92a65e; font-weight: bold;">&amp;body</span> body)
  <span style="color: #95e454;">"Bind LINE-VAR to each line in SPEC specified file and execute BODY."</span>
  (<span style="color: #8ac6f2; font-weight: bold;">let*</span> ((entry-size (spec-size spec))  <span style="color: #99968b;">;entry size is known</span>
         (line-size (1+ entry-size))    <span style="color: #99968b;">;add 1 for newline</span>
         (buffer-size (<span style="color: #8ac6f2; font-weight: bold;">if</span> (&lt; line-size +max-buffer-size+)
                          (* line-size (floor +max-buffer-size+ line-size))
                          line-size))
         (ins (gensym)) <span style="color: #99968b;">;make sure the file stream variable is not visible to the body</span>
         (buffer (gensym))    <span style="color: #99968b;">;-//- for read buffer</span>
         (bytes (gensym))     <span style="color: #99968b;">;-//- for number of bytes read</span>
         (offset (gensym)))   <span style="color: #99968b;">;-//- current line within buffer offset</span>
    `(<span style="color: #8ac6f2; font-weight: bold;">let</span> ((,buffer (make-array ,buffer-size <span style="color: #e5786d;">:element-type</span> 'ub-char)) <span style="color: #99968b;">;allocate read</span>
           (,line-var (make-string ,entry-size <span style="color: #e5786d;">:element-type</span> 'base-char))) <span style="color: #99968b;">;and line buffers</span>
       (<span style="color: #8ac6f2; font-weight: bold;">declare</span> (dynamic-extent ,buffer ,line-var)) <span style="color: #99968b;">;use stack allocation if possible</span>
       (<span style="color: #8ac6f2; font-weight: bold;">with-open-file</span> (,ins ,(spec-path spec) <span style="color: #e5786d;">:direction</span> <span style="color: #e5786d;">:input</span>
                                               <span style="color: #e5786d;">:element-type</span> 'ub-char)
         (<span style="color: #8ac6f2; font-weight: bold;">loop</span> for ,bytes fixnum = (read-sequence ,buffer ,ins) <span style="color: #99968b;">;read as many lines</span>
               until (zerop ,bytes)
               <span style="color: #99968b;">;; </span><span style="color: #99968b;">slide offset through the buffer</span>
               do (<span style="color: #8ac6f2; font-weight: bold;">loop</span> for ,offset fixnum from 0 below (* ,line-size
                                                           (floor ,bytes ,line-size))
                                           by ,line-size
                        <span style="color: #99968b;">;; </span><span style="color: #99968b;">fill line with the current window bytes while converting them</span>
                        do (<span style="color: #8ac6f2; font-weight: bold;">loop</span> for i fixnum from 0 below ,entry-size
                                 for j fixnum from ,offset
                                 do (setf (aref ,line-var i) (code-char (aref ,buffer j))))
                        ,@body)))))) <span style="color: #99968b;">;the body only sees the line variable as before</span>
</pre>
</div>

<p>
Skeleton is same as before, we only add a buffer dedicated to reading
several lines at once and then slide through it, copying and
converting bytes to the line variable.  With this, performance goes
around 1.5 - 2 times slower than C++.  But we can do better!
</p>
</div>
</div>

<div id="outline-container-orgbb2bfcc" class="outline-3">
<h3 id="orgbb2bfcc"><span class="section-number-3">4.10</span> Squeezing performance 2</h3>
<div class="outline-text-3" id="text-4-10">
<p>
To go further we can try to leave aside copying and converting raw
bytes and instead apply comparisons directly over them (what C++
does).  So I <a href="https://www.quicklisp.org/">Quicklisp</a>-ed the <b>ascii-strings</b> contrib of the
<a href="https://bitbucket.org/vityok/cl-string-match">cl-string-match</a> library to help with this.  Unfortunately I couldn't
find substitute for the regex matcher that works on byte arrays, so
we'd still have to make conversion for fields which are matched
against regex.
</p>

<p>
This requires changes mostly in <a href="#org36dd665">gen-field-clause</a> and friends, slight
adjustment to <a href="#org4b11d40">gen-print-selection</a> and removing the line conversion
loop from the improved <a href="#org31e949e">do-lines</a>.  Here's a prototype sketch of the
desired expansion (<b>#.</b> is a <a href="#orgc141078">reader macro</a> which evaluates the
following expression at read-time):
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #8ac6f2; font-weight: bold;">lambda</span> ()
  (<span style="color: #8ac6f2; font-weight: bold;">declare</span> (optimize (speed 3) (debug 0) (safety 0) (compilation-speed 0)))
  (<span style="color: #8ac6f2; font-weight: bold;">let</span> ((buffer (make-array #.(* 57 (floor +max-buffer-size+ 57)) <span style="color: #99968b;">;raw byte buffer</span>
                            <span style="color: #e5786d;">:element-type</span> 'ub-char))
        <span style="color: #99968b;">;;</span><span style="color: #99968b;">pre-allocated string used for regex matching</span>
        (line (make-string 56 <span style="color: #e5786d;">:element-type</span> 'base-char)))
    (<span style="color: #8ac6f2; font-weight: bold;">declare</span> (dynamic-extent buffer line)) <span style="color: #99968b;">;stack allocate</span>
    (<span style="color: #8ac6f2; font-weight: bold;">with-open-file</span> (in #P<span style="color: #95e454;">"/path/to/recordS5.db"</span> <span style="color: #e5786d;">:direction</span> <span style="color: #e5786d;">:input</span>
                                                 <span style="color: #e5786d;">:element-type</span> 'ascii:ub-char)
      (<span style="color: #8ac6f2; font-weight: bold;">loop</span> for bytes fixnum = (read-sequence buffer in) <span style="color: #99968b;">;load as many lines at once</span>
            until (zerop bytes)
            do (<span style="color: #8ac6f2; font-weight: bold;">loop</span> for offset fixnum from 0 below (* 57 (floor bytes 57)) by 57
                     do (<span style="color: #8ac6f2; font-weight: bold;">when</span>      <span style="color: #99968b;">;for each entry in the loaded chunk</span>
                            (and (<span style="color: #8ac6f2; font-weight: bold;">progn</span> <span style="color: #99968b;">;fill bytes of this field in string</span>
                                   (<span style="color: #8ac6f2; font-weight: bold;">loop</span> for i fixnum from 2 below 4 <span style="color: #99968b;">;before regex matching</span>
                                         for j fixnum from (+ offset 2)
                                         do (setf (aref line i)
                                                  (code-char (aref buffer (+ offset i)))))
                                   (cl-ppcre:scan <span style="color: #95e454;">"XX|YY"</span> line <span style="color: #e5786d;">:start</span> 2 <span style="color: #e5786d;">:end</span> 4))
                                 (or <span style="color: #99968b;">;convert filter string to bytes at macro expansion</span>
                                  (and (search #.(ascii:string-to-ub <span style="color: #95e454;">"PET"</span>)
                                        <span style="color: #99968b;">;the PET thing will turn to #(80 69 84)</span>
                                               buffer <span style="color: #e5786d;">:start1</span> 0 <span style="color: #e5786d;">:end1</span> 3 <span style="color: #99968b;">;and match against</span>
                                               <span style="color: #e5786d;">:start2</span> (+ offset 40) <span style="color: #99968b;">;the raw field bytes</span>
                                               <span style="color: #e5786d;">:end2</span> (+ offset 56))
                                       (= (aref buffer (+ offset 7))
                                          #.(char-code #\C)))<span style="color: #99968b;">;convert char to byte</span>
                                  (and (= (aref buffer (+ offset 7))
                                                       #.(char-code #\F))
                                       (and <span style="color: #99968b;">;MEAL comparison</span>
                                         (= (aref buffer (+ offset 40)) 77)
                                         (= (aref buffer (+ offset 41)) 69)
                                         (= (aref buffer (+ offset 42)) 65)
                                         (= (aref buffer (+ offset 43)) 76))))
                                 (<span style="color: #8ac6f2; font-weight: bold;">cond</span>  <span style="color: #99968b;">;"180620" comparison</span>
                                   ((/= 49 (aref buffer (+ offset 14)))
                                    (&lt; 49 (aref buffer (+ offset 14))))
                                   ((/= 56 (aref buffer (+ offset 15)))
                                    (&lt; 56 (aref buffer (+ offset 15))))
                                   ((/= 48 (aref buffer (+ offset 16)))
                                    (&lt; 48 (aref buffer (+ offset 16))))
                                   ((/= 54 (aref buffer (+ offset 17)))
                                    (&lt; 54 (aref buffer (+ offset 17))))
                                   ((/= 50 (aref buffer (+ offset 18)))
                                    (&lt; 50 (aref buffer (+ offset 18))))
                                   (t (&lt; 48 (aref buffer (+ offset 19)))))
                                 (<span style="color: #8ac6f2; font-weight: bold;">cond</span>  <span style="color: #99968b;">;eff &lt; disc dates</span>
                                   ((/= (aref buffer (+ offset 8))
                                        (aref buffer (+ offset 14)))
                                    (&lt; (aref buffer (+ offset 8))
                                       (aref buffer (+ offset 14))))
                                   ((/= (aref buffer (+ offset 9))
                                        (aref buffer (+ offset 15)))
                                    (&lt; (aref buffer (+ offset 9))
                                       (aref buffer (+ offset 15))))
                                   ((/= (aref buffer (+ offset 10))
                                        (aref buffer (+ offset 16)))
                                    (&lt; (aref buffer (+ offset 10))
                                       (aref buffer (+ offset 16))))
                                   ((/= (aref buffer (+ offset 11))
                                        (aref buffer (+ offset 17)))
                                    (&lt; (aref buffer (+ offset 11))
                                       (aref buffer (+ offset 17))))
                                   ((/= (aref buffer (+ offset 12))
                                        (aref buffer (+ offset 18)))
                                    (&lt; (aref buffer (+ offset 12))
                                       (aref buffer (+ offset 18))))
                                   (t
                                    (&lt; (aref buffer (+ offset 13))
                                       (aref buffer (+ offset 19))))))
                          (<span style="color: #8ac6f2; font-weight: bold;">progn</span>
                            <span style="color: #99968b;">;; </span><span style="color: #99968b;">(write-string line nil :start 2 :end 4) ?</span>
                            (<span style="color: #8ac6f2; font-weight: bold;">loop</span> for i fixnum from (+ offset 2) below (+ offset 4)
                                  do (write-char (code-char (aref buffer i))))
                            (<span style="color: #8ac6f2; font-weight: bold;">loop</span> for i fixnum from (+ offset 5) below (+ offset 8)
                                  do (write-char (code-char (aref buffer i))))
                            (<span style="color: #8ac6f2; font-weight: bold;">loop</span> for i fixnum from (+ offset 40) below (+ offset 56)
                                  do (write-char (code-char (aref buffer i))))
                            (<span style="color: #8ac6f2; font-weight: bold;">loop</span> for i fixnum from (+ offset 14) below (+ offset 20)
                                  do (write-char (code-char (aref buffer i))))
                            (format t <span style="color: #95e454;">"~%"</span>))))))))
</pre>
</div>

<p>
Now, that begins to look a bit more compilish.  Here's what changed:
</p>

<ul class="org-ul">
<li>use raw byte comparison operations; convert constant filters to raw
bytes during macro expansion; add current line <b>offset</b> to field
offsets since now working over the buffer</li>

<li>unroll all non-regex comparisons</li>

<li>lazily fill parts of <b>line</b> before regex matching; optionally, in
case a field is matched in multiple places (not the case for this
query), we can mark its first byte position with special character
at the start of line validation to signal that it has to be filled
and can skip filling on subsequent operations over the same line</li>
</ul>

<p>
I won't go into detailed implementation, the previous snippets should
have shown how programmatically manipulating code in Lisp is
indistinguishable from juggling with data.  These adjustments are not
really rocket science.  You can see a more elaborate and complete
implementation in <a href="https://github.com/m00natic/fdbq">fdbq</a>.
</p>
</div>
</div>

<div id="outline-container-orgd043a43" class="outline-3">
<h3 id="orgd043a43"><span class="section-number-3">4.11</span> Measurements</h3>
<div class="outline-text-3" id="text-4-11">
<p>
After the above squeezing, here are processing times I observe with
analogical query over a little 1GB db with 6.4 million entries sized
159 (sequential scan takes 0.4 seconds at best) with couple of
idealized <a href="#orgb2632cf">one-off versions</a> (not real solutions of course) for
reference:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Language</th>
<th scope="col" class="org-left">Implementation</th>
<th scope="col" class="org-left">Approach</th>
<th scope="col" class="org-right">Threads</th>
<th scope="col" class="org-right">Time (sec)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Common Lisp</td>
<td class="org-left">SBCL 1.4.10</td>
<td class="org-left">II</td>
<td class="org-right">4</td>
<td class="org-right">1.30</td>
</tr>

<tr>
<td class="org-left">C++</td>
<td class="org-left">GCC 8.2 -O3</td>
<td class="org-left">I<sup><a id="fnr.7" class="footref" href="#fn.7">7</a></sup></td>
<td class="org-right">4</td>
<td class="org-right">1.30</td>
</tr>

<tr>
<td class="org-left">C++</td>
<td class="org-left">Clang 6.0.1 -O3</td>
<td class="org-left">I<sup><a id="fnr.7.100" class="footref" href="#fn.7">7</a></sup></td>
<td class="org-right">4</td>
<td class="org-right">1.34</td>
</tr>

<tr>
<td class="org-left">C++</td>
<td class="org-left">GCC 8.2 -O3</td>
<td class="org-left">one-off</td>
<td class="org-right">1</td>
<td class="org-right">2.42</td>
</tr>

<tr>
<td class="org-left">C++</td>
<td class="org-left">Clang 6.0.1 -O3</td>
<td class="org-left">one-off</td>
<td class="org-right">1</td>
<td class="org-right">2.49</td>
</tr>

<tr>
<td class="org-left">Common Lisp</td>
<td class="org-left">Clozure 1.12<sup><a id="fnr.8" class="footref" href="#fn.8">8</a></sup></td>
<td class="org-left">II</td>
<td class="org-right">4</td>
<td class="org-right">2.62</td>
</tr>

<tr>
<td class="org-left">C++</td>
<td class="org-left">GCC 8.2 -O3</td>
<td class="org-left">I<sup><a id="fnr.7.100" class="footref" href="#fn.7">7</a></sup></td>
<td class="org-right">1</td>
<td class="org-right">2.70</td>
</tr>

<tr>
<td class="org-left">C++</td>
<td class="org-left">Clang 6.0.1 -O3</td>
<td class="org-left">I<sup><a id="fnr.7.100" class="footref" href="#fn.7">7</a></sup></td>
<td class="org-right">1</td>
<td class="org-right">2.76</td>
</tr>

<tr>
<td class="org-left">Common Lisp</td>
<td class="org-left">SBCL 1.4.10</td>
<td class="org-left">II</td>
<td class="org-right">1</td>
<td class="org-right">2.90</td>
</tr>

<tr>
<td class="org-left">Go</td>
<td class="org-left">Go 1.10.3</td>
<td class="org-left">one-off</td>
<td class="org-right">1</td>
<td class="org-right">4.02</td>
</tr>

<tr>
<td class="org-left">Common Lisp</td>
<td class="org-left">Clozure 1.12</td>
<td class="org-left">II</td>
<td class="org-right">1</td>
<td class="org-right">5.04</td>
</tr>

<tr>
<td class="org-left">Python</td>
<td class="org-left">CPython 3.7.0</td>
<td class="org-left">one-off</td>
<td class="org-right">1</td>
<td class="org-right">15.50</td>
</tr>

<tr>
<td class="org-left">Python</td>
<td class="org-left">CPython 2.7.15</td>
<td class="org-left">one-off</td>
<td class="org-right">1</td>
<td class="org-right">18.07</td>
</tr>
</tbody>
</table>

<p>
(the parallelized C++ <span class="underline">versions</span> are straightforward <a href="https://en.wikipedia.org/wiki/Mmap">memory map</a> based,
while the CL <span class="underline">complete solutions</span> still use sequential file reads)
</p>

<p>
Not bad for a "slow" dynamic language!  Anyway, CL and SBCL's
single thread disadvantage here comes from:
</p>

<ul class="org-ul">
<li>absence of regex matcher which works over byte arrays rather than
strings</li>
<li>sequence comparisons are not <a href="https://en.wikipedia.org/wiki/SIMD">vectorized</a> for now (though the
unrolling pretty much neutralizes that)</li>
</ul>

<p>
How does it compensate during parallelization?  It may have something
to do with the excellent <a href="https://lparallel.org/">lparallel</a> library allowing easily wipe a
scheme which better saturates the CPUs while playing well with the
system caches.
</p>
</div>
</div>
</div>

<div id="outline-container-org8292046" class="outline-2">
<h2 id="org8292046"><span class="section-number-2">5</span> Addendum</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-org2811300" class="outline-3">
<h3 id="org2811300"><span class="section-number-3">5.1</span> Manual JIT</h3>
<div class="outline-text-3" id="text-5-1">
<p>
Here's the essence of <b>Approach II</b>:
</p>


<div class="figure">
<p><img src="./arch.png" alt="arch.png" />
</p>
</div>

<p>
I like to call this tactic of plugging Ahead-Of-Time compilation on
the fly (run-time) over newly assembled specialized code "Manual
Just-In-Time compilation".  Works at a higher level than "automatic"
<a href="https://en.wikipedia.org/wiki/Just-in-time_compilation">JIT</a> and opens opportunities for greater while orthogonal gain and as
seen - even algorithm simplification.  This doesn't work (at least is
not portable) for languages which leave only minimal dead skeleton of
the program for run-time like&#x2026;er, about all compiled languages
(unless <a href="https://en.wikipedia.org/wiki/Greenspun%27s_tenth_rule">greenspunning</a>).  It's idiomatic and easily available in most
Lisps through macros.  Common Lisp is especially suited with:
</p>

<ul class="org-ul">
<li>compiler can be explicitly evoked at run-time (the <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_cmp.htm">compile</a> function)</li>
<li>per function re/compilation over several <a href="http://www.lispworks.com/documentation/HyperSpec/Body/d_optimi.htm">dimensions and levels of optimization</a></li>
<li>per function <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_disass.htm">disassembly</a></li>
<li>optional type declarations</li>
<li>designed for system evolution, including <a href="http://www.gigamonkeys.com/book/object-reorientation-generic-functions.html">CLOS</a><sup><a id="fnr.9" class="footref" href="#fn.9">9</a></sup>, the object
system</li>
<li>truly multi-paradigm without pushing ahead any particular style<sup><a id="fnr.10" class="footref" href="#fn.10">10</a></sup></li>
</ul>

<p>
Some CL implementations can leverage type declarations to rival static
language <a href="https://en.wikipedia.org/wiki/Ahead-of-time_compilation">AOT</a> compilers<sup><a id="fnr.11" class="footref" href="#fn.11">11</a></sup>.  SBCL has certain ability to perform
<a href="https://en.wikipedia.org/wiki/Type_inference">type inference</a> during compilation and beside type errors, even
provides hints where and why a micro-optimization couldn't be applied
to guide type declaration refinements:
</p>

<pre class="example">
source.lisp:4:3:
  note: 
    forced to do GENERIC-+ (cost 10)
          unable to do inline fixnum arithmetic (cost 2) because:
          The second argument is a NUMBER, not a FIXNUM.
          The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
          unable to do inline (signed-byte 64) arithmetic (cost 5) because:
          The second argument is a NUMBER, not a (SIGNED-BYTE 64).
          The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64)
                                                                   &amp;REST T).
          etc.
</pre>

<p>
As the examples show, Common Lisp actually has unexpectedly rich <a href="http://www.lispworks.com/documentation/HyperSpec/Body/04_bc.htm">type
system</a>.  Combine this with <a href="https://en.wikipedia.org/wiki/Metaprogramming">metaprogramming</a> (where Lisps excel at) and
one can generate pretty trimmed static code where needed.
</p>

<p>
The ability to see how a function's disassembly changes after code
adjustments is also quite helpful and insightful.
</p>
</div>

<div id="outline-container-orgcd74204" class="outline-4">
<h4 id="orgcd74204"><span class="section-number-4">5.1.1</span> Eval?</h4>
<div class="outline-text-4" id="text-5-1-1">
<p>
I can hear you say:
</p>

<blockquote>
<p>
<i>THE PARENTHESIS, MY EYES!  Sir, just use "modern" dynamic language
which provides <b>eval</b>.</i>
</p>
</blockquote>

<p>
And you'd be right with these caveats:
</p>

<ul class="org-ul">
<li>string manipulation to cover random syntax is uncomfortable and
error prone</li>
<li>the possible alternative of building explicit internal <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">AST</a> objects
is more robust but just as clunky and non composable</li>
<li>it's still interpretation, not compilation</li>
<li>huge majority of dynamic languages which are not Lisps are indeed
pathetically slow (<a href="http://luajit.org/luajit.html">LuaJIT</a>, <a href="https://julialang.org/">Julia</a> being exceptions, though the latter
is rather Lisp with default random syntax<sup><a id="fnr.12" class="footref" href="#fn.12">12</a></sup>)</li>
</ul>

<p>
In contrast to random-syntax code-is-a-string/file-blob languages,
Lisps deal with already parsed trees basically all the time.  Simple
and reliable to generate, traverse, transform.  DSLs become so easy to
implement, it feels like cheating.
</p>
</div>
</div>

<div id="outline-container-org61136b9" class="outline-4">
<h4 id="org61136b9"><span class="section-number-4">5.1.2</span> Quasi-quotation remark</h4>
<div class="outline-text-4" id="text-5-1-2">
<p>
Nowadays there's multitude of languages that bolt on <a href="https://en.wikipedia.org/wiki/Quasi-quotation">quasi-quote</a>
macros in the style of Common Lisp backquote expressions.  And people
are quick to assume that Lisps are now completely assimilated by more
mainstream languages, yadda yadda (obviously never heard of <a href="http://www.gigamonkeys.com/book/object-reorientation-generic-functions.html">CLOS</a> or
CL's <a href="http://www.gigamonkeys.com/book/beyond-exception-handling-conditions-and-restarts.html">condition system</a>).  Some of them are even statically typed,
though these often have limitations on what can be done at compile
time.  They are normally nice enough to easily implement syntax sugar
like the simple version of <a href="#org0434eb9">do-lines</a>.  But once a task gets a bit
harder like having to introspect, generate non trivially structured
code and/or combine transformations - implementation (if at all
possible) degrades to undecipherable syntax noise that requires PhD to
figure out.  And the reason is that unlike Lisps, their random syntax
is hardly representative of the abstract syntax trees the
interpreter/compiler works with.  So they invent yet another random
syntax sub-language to bridge them.  These ain't "acceptable Lisps".
</p>
</div>
</div>
</div>

<div id="outline-container-orgc141078" class="outline-3">
<h3 id="orgc141078"><span class="section-number-3">5.2</span> Life stages of a program</h3>
<div class="outline-text-3" id="text-5-2">
<p>
Where metaprogramming power comes from?  Beside the infamous uniform
structured syntax which allows <a href="https://en.wikipedia.org/wiki/Homoiconicity">duality between code and data</a>, Lisps
normally make distinction between several possibly interleaving and
recurring phases of program existence and provide hooks into them.  Or
rather rewrite rules.  And what language would you reprogram them in,
some dumb pre-processor or half-assed template engine?  No,
<a href="https://en.wikipedia.org/wiki/Turtles_all_the_way_down">it's turtles all the way</a>!
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Phase</th>
<th scope="col" class="org-left">Description</th>
<th scope="col" class="org-left">Control entry point</th>
<th scope="col" class="org-left">Common Lisp</th>
<th scope="col" class="org-left">Racket<sup><a id="fnr.13" class="footref" href="#fn.13">13</a></sup></th>
<th scope="col" class="org-left">Scheme</th>
<th scope="col" class="org-left">Clojure</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Read-time</td>
<td class="org-left">the moment a set of characters is fed to the Lisp reader</td>
<td class="org-left">reader macros</td>
<td class="org-left">o</td>
<td class="org-left">o</td>
<td class="org-left"><a href="https://srfi.schemers.org/srfi-10/srfi-10.html">SRFI-10</a></td>
<td class="org-left">x</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">Macro expansion time</td>
<td class="org-left">actually initial part of compile-time, regular macros are expanded on demand</td>
<td class="org-left">macros</td>
<td class="org-left">o</td>
<td class="org-left">o</td>
<td class="org-left">o</td>
<td class="org-left">o</td>
</tr>

<tr>
<td class="org-left">Compile-time</td>
<td class="org-left">when compiler is just about to assemble runnable (possibly machine) code, all reader and regular macros have already been expanded and only functions left</td>
<td class="org-left">compiler macros</td>
<td class="org-left">o</td>
<td class="org-left">?</td>
<td class="org-left">x</td>
<td class="org-left">x</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">Run-time</td>
<td class="org-left">execution</td>
<td class="org-left">functions</td>
<td class="org-left">o</td>
<td class="org-left">o</td>
<td class="org-left">o</td>
<td class="org-left">o</td>
</tr>
</tbody>
</table>

<p>
While the above seems like the natural sequence of "events" - <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_rd_rd.htm">read</a>,
<a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_cmp.htm">compile</a>, can additionally happen at any time as any other function
call (one of several reasons to prefer functions to macros when in
doubt).  Notice how the <a href="#org245b3b7">select</a> macro is knitted together by amalgam of
built-in and user defined functions and macros.  Here's wildly
approximate sketch how it may bounce around the phases after user
invocation:
</p>


<div class="figure">
<p><img src="./phases.png" alt="phases.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org3021a61" class="outline-3">
<h3 id="org3021a61"><span class="section-number-3">5.3</span> Image based development and deploy</h3>
<div class="outline-text-3" id="text-5-3">
<p>
Think Lisp tricks end here?  Common Lisp like <a href="https://en.wikipedia.org/wiki/Smalltalk">Smalltalk</a> is not just a
compiler but an image environment.  The image initially contains just
the core language (and reader + compiler and/or interpreter) and is
incrementally extended and changed during development/user
interaction.  Be it by loading libraries, re/defining functions,
constants, re/setting global variables, executing code with side
effects etc.
</p>

<p>
How would one produce user facing executable?  Dump the current
image<sup><a id="fnr.14" class="footref" href="#fn.14">14</a></sup>.  This opens opportunity to also embed data within the
image before dumping which would otherwise have to be loaded, parsed,
pre/processed during execution.
</p>

<p>
For our little query engine such data are the configuration
specifications for the multiple dbs.  These rarely change and makes
sense to be parsed down to particular structure instances and put into
a global hash table variable for example before dump thus becoming
available and ready to use immediately on image execution.  This would
additionally improve executable's latency for queries.
</p>
</div>
</div>

<div id="outline-container-org12d6c6f" class="outline-3">
<h3 id="org12d6c6f"><span class="section-number-3">5.4</span> Alternative syntax</h3>
<div class="outline-text-3" id="text-5-4">
<p>
One may object that all falls into place only if we "limit" users to
S-expression DSLs.  What if forced to literary provide SQL syntax?
Common Lisp in particular has <a href="http://www.lispworks.com/documentation/HyperSpec/Body/23_aa.htm">reprogrammable reader</a> through <a href="#orgc141078">reader
macros</a> which allows performing read-time transformation (before
"regular" <a href="#orgc141078">macro expansion time</a>) of more funky syntax (with some
limits) to good ole S-expressions.  We'll have to do some parsing by
ourselves, like animals, but using this would allow us keep rest of
our solution unchanged.
</p>
</div>
</div>
</div>

<div id="outline-container-orgae062fb" class="outline-2">
<h2 id="orgae062fb"><span class="section-number-2">6</span> Further reading</h2>
<div class="outline-text-2" id="text-6">
<p>
Looking at conference materials, lispers (at least the Common breed)
at times take advantage of such techniques<sup><a id="fnr.15" class="footref" href="#fn.15">15</a></sup> for difficult
problems but seem troubled to gain attention of the outside world.
</p>

<p>
I've been cheering for the <a href="https://medium.com/@MartinCracauer/a-gentle-introduction-to-compile-time-computing-part-1-d4d96099cea0">Gentle Introduction to Compile-Time
Computing</a> series to really launch for deeper descend into the matter
but even the outline can suggest what sort of magic is possible.
</p>

<p>
Traditional recommendations for macro black belting are <a href="http://www.paulgraham.com/onlisp.html">On Lisp:
Advanced Techniques for Common Lisp</a> and its logical successor <a href="https://letoverlambda.com/">Let Over
Lambda</a>.  <a href="https://en.wikipedia.org/wiki/The_Art_of_the_Metaobject_Protocol">The Art of the Metaobject Protocol</a> is the bible of object
system metaprogramming.  <a href="https://github.com/norvig/paip-lisp">Paradigms of Artificial Intelligence
Programming: Case Studies in Common Lisp</a> is an instructive showoff how
complex systems become not so complex with a powerful language and
clear idea.
</p>

<p>
Most of the above require CL familiarity.  If one lacks such, <a href="http://stevelosh.com/blog/2018/08/a-road-to-common-lisp/">A road
to Common Lisp</a> is an excellent getting started guide.  Newcomers are
generally recommended <a href="http://www.gigamonkeys.com/book/">Practical Common Lisp</a> or if more humourous: <a href="http://landoflisp.com/">Land
Of Lisp</a>; more seasoned practitioners: <a href="http://weitz.de/cl-recipes/">Common Lisp Recipes</a>.  For an
advanced development environment, one can try <a href="https://portacle.github.io/">Portacle</a> or possibly <a href="https://github.com/cxxxr/lem">Lem</a>
if not much into Emacs.
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
One may rightfully note that such data seems plain meant for SQL
storage.  There are some complications in reality including size,
performance needs and slight deviations from the fixed format why this
is not done.
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">
Although Common Lisp (CL) is <a href="https://en.wikipedia.org/wiki/Type_system">dynamically typed</a> (also strongly typed)
and everyone "knows" such languages are doomed to be slow, CL is rare
exception.  One reason is <a href="https://en.wikipedia.org/wiki/Common_lisp">history</a>.  Lisps were the primordial wave of
<a href="https://en.wikipedia.org/wiki/Dynamic_programming_language">dynamic languages</a> and had to run acceptably on quite limited hardware
compared to nowadays.  Thus they were crafted in ways where
possibility for performance optimizations were kept in sight and with
<a href="https://en.wikipedia.org/wiki/Moore%27s_law">Moore's law</a> still progressing - they were gradually catching up the
statically typed languages.  To the point where <a href="https://en.wikipedia.org/wiki/Genera_(operating_system)">operating systems</a> were
written from the ground up.  With Common Lisp being merger of the
original line of dialects, there are many places in its specification
where freeways for implementations to perform optimizations are
present.
</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3">3</a></sup> <div class="footpara"><p class="footpara">
The interpreter approach in a "usual" (or as they say - blub)
language should also do this before the iteration begins but there's
no way to specialize the code structure at that point, only the data.
</p></div></div>

<div class="footdef"><sup><a id="fn.4" class="footnum" href="#fnr.4">4</a></sup> <div class="footpara"><p class="footpara">
Some CL implementations work only as interpreters, others only as
compilers. It will be all the same in such case.  Talking of CL
implementations, there's bunch of standard compliant ones with
different pros and cons - here's slightly outdated <a href="https://common-lisp.net/~dlw/LispSurvey.html">survey</a> on most of
them.  Probably the biggest omission is the recent <a href="https://github.com/clasp-developers/clasp">Clasp</a>
implementation.
</p></div></div>

<div class="footdef"><sup><a id="fn.5" class="footnum" href="#fnr.5">5</a></sup> <div class="footpara"><p class="footpara">
Array bound checks should be unconditionally elided within the
<b>(safety 0)</b> <a href="http://www.lispworks.com/documentation/HyperSpec/Body/d_optimi.htm">optimization level</a>.  In case we decide to go
berserk&#x2026; like C/C++'s only mode of operation for <a href="https://en.wikipedia.org/wiki/Plain_old_data">POD</a> types.
</p></div></div>

<div class="footdef"><sup><a id="fn.6" class="footnum" href="#fnr.6">6</a></sup> <div class="footpara"><p class="footpara">
If one may object that C++ code in this article is somewhat
less, thus perceivably simpler - remember, it presents just smaller
part of a full solution.
</p></div></div>

<div class="footdef"><sup><a id="fn.7" class="footnum" href="#fnr.7">7</a></sup> <div class="footpara"><p class="footpara">
That's <b>Approach I</b> without actual query parsing, just a
mocked up specific WHERE tree instance.  So not quite a real solution
either, thus times are a bit optimistic.  Yeah, I'm lazy (and life's
too short for so much C++ ceremony).
</p></div></div>

<div class="footdef"><sup><a id="fn.8" class="footnum" href="#fnr.8">8</a></sup> <div class="footpara"><p class="footpara">
The <a href="https://ccl.clozure.com/">Clozure</a> Common Lisp implementation is not to be confused
with the <a href="https://clojure.org/">Clojure</a> language, also part of the Lisp family.
</p></div></div>

<div class="footdef"><sup><a id="fn.9" class="footnum" href="#fnr.9">9</a></sup> <div class="footpara"><p class="footpara">
For instance see the <a href="http://www.lispworks.com/documentation/HyperSpec/Body/04_cf.htm">Redefining Classes</a> machinery in the <a href="http://www.lispworks.com/documentation/HyperSpec/Front/Contents.htm">Common
Lisp HyperSpec</a>.
</p></div></div>

<div class="footdef"><sup><a id="fn.10" class="footnum" href="#fnr.10">10</a></sup> <div class="footpara"><p class="footpara">
Beside metaprogrammability and being as imperative as it gets,
CL sports fantastic object system, has adequate out of the box support
for functional style and <a href="http://www.lispworks.com/documentation/HyperSpec/Body/12_aac.htm">lower level bit-twiddling</a> at the same time.
Generally, it can assimilate many outside paradigms as if they were
native thanks to being the programmable programming language.  There
are library extensions for <a href="https://cliki.net/Prolog">logic programming</a>, <a href="http://lisa.sourceforge.net/">expert systems</a>,
<a href="http://nikodemus.github.io/screamer/">nondeterministic and constraint programming</a>, <a href="https://github.com/guicho271828/trivia">pattern matching</a>,
<a href="https://borodust.github.io/projects/cl-flow/">dataflow</a>&#x2026; which normally blend with rest of the language, just like
user code becomes indistinguishable from the core functionality.
</p></div></div>

<div class="footdef"><sup><a id="fn.11" class="footnum" href="#fnr.11">11</a></sup> <div class="footpara"><p class="footpara">
See <a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/which-programs-are-fast.html">The Computer Language Benchmarks Game</a> to get rough
idea. With all the usual toy micro benchmark disclaimers, Common
Lisp/SBCL's competitiveness against statically typed languages is kind
of embarrassing to the latter.  And that's using same algorithms.
</p></div></div>

<div class="footdef"><sup><a id="fn.12" class="footnum" href="#fnr.12">12</a></sup> <div class="footpara"><p class="footpara">
Julia can almost match Common Lisp for this query engine
thing.  However, it seems to only be able to invoke (implicitly) the
compiler at run-time for <a href="https://docs.julialang.org/en/latest/manual/metaprogramming/#Generated-functions-1">generated functions</a> which only see argument
types.  This is not sufficient for our queries.  Thus <a href="https://docs.julialang.org/en/latest/devdocs/eval/">eval</a>
interpretation has to be used and the compiler wouldn't be able to
optimize the run-time generated code.  In this case <b>Approach I</b> being
subject to "normal" AOT compilation may well fare better.  In
contrast, with Common Lisp we are able to explicitly summon the
compiler with full optimization over arbitrary generated function.
</p></div></div>

<div class="footdef"><sup><a id="fn.13" class="footnum" href="#fnr.13">13</a></sup> <div class="footpara"><p class="footpara">
The table is from Common Lisp's perspective but <a href="https://racket-lang.org/">Racket</a> seems to
have even more elaborate <a href="https://docs.racket-lang.org/guide/phases.html">macro phase system</a>.  Part of the reason is
Racket, being a <a href="https://en.wikipedia.org/wiki/Scheme_%28programming_language%29">Scheme</a> descendant, has single namespace for functions
and variables (<a href="https://en.wikipedia.org/wiki/Common_Lisp#The_function_namespace">Lisp-1</a>).  And all those crazy academics!
</p></div></div>

<div class="footdef"><sup><a id="fn.14" class="footnum" href="#fnr.14">14</a></sup> <div class="footpara"><p class="footpara">
Among other things, the <a href="https://gitlab.common-lisp.net/asdf/asdf/tree/master/uiop">uiop</a> library provides portable wrapper
to dump images for various implementations.
</p></div></div>

<div class="footdef"><sup><a id="fn.15" class="footnum" href="#fnr.15">15</a></sup> <div class="footpara"><p class="footpara">
Like <a href="https://european-lisp-symposium.org/static/2018/heisig.pdf">Petalisp - A Common Lisp Library for Data Parallel Programming</a>
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<p class="author">Author: Andrey Kotlarski</p>
<p class="date">Created: 2018-11-18 нд 16:49</p>
<p class="creator"><a href="https://www.gnu.org/software/emacs/">Emacs</a> 26.1 (<a href="https://orgmode.org">Org</a> mode 9.1.9)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
