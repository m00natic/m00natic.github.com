<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2018-07-31 вт 04:41 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Uniform Structured Syntax, Meta Programming and Runtime Compilation</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Andrey Kotlarski" />
<meta name="description" content="Real world example where uniform syntax enables unthinkable solution"
 />
<meta name="keywords" content="meta-programming, syntax, lisp, compilation, optimization" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="css/worg-classic.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="sitemap.html"> UP </a>
 |
 <a accesskey="H" href="index.html"> HOME </a>
</div><div id="content">
<h1 class="title">Uniform Structured Syntax, Meta Programming and Runtime Compilation</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org3be35d9">1. Intro</a></li>
<li><a href="#orga67b786">2. The Problem</a></li>
<li><a href="#orgf77d741">3. Approach I</a>
<ul>
<li><a href="#orgc4bb03c">3.1. WHERE tree</a></li>
<li><a href="#org551a029">3.2. WHERE matcher</a></li>
</ul>
</li>
<li><a href="#orgbdfcb19">4. Approach II</a>
<ul>
<li><a href="#org75f9003">4.1. Prelude</a></li>
<li><a href="#orgdd62685">4.2. Embedded domain specific languages</a></li>
<li><a href="#org2233a27">4.3. WHERE tree</a></li>
</ul>
</li>
<li><a href="#org5cf63d7">5. Addendum</a>
<ul>
<li><a href="#org503883b">5.1. Manual JIT</a>
<ul>
<li><a href="#org9011cdd">5.1.1. Eval?</a></li>
</ul>
</li>
<li><a href="#org71f35ef">5.2. Alternative syntax</a></li>
</ul>
</li>
<li><a href="#org3562ff9">6. Further reading</a></li>
</ul>
</div>
</div>

<div id="outline-container-org3be35d9" class="outline-2">
<h2 id="org3be35d9"><span class="section-number-2">1</span> Intro</h2>
<div class="outline-text-2" id="text-1">
<p>
Often times I hear the claim that (programming language) syntax
doesn't matter or if it does, it's only to provide some subjective
readability aestetics.  It's somewhat surprising to me how large
majority of supposedly rational people like programmers/computer
scientists would throw out objectivity with such confidence.  So let
me provide a real world case where uniform syntax enables out of the
box solution which is qualitatively simpler.  Also there's popular
belief that abstraction and flexibility are at odds with performance.
Watch out!
</p>
</div>
</div>

<div id="outline-container-orga67b786" class="outline-2">
<h2 id="orga67b786"><span class="section-number-2">2</span> The Problem</h2>
<div class="outline-text-2" id="text-2">
<p>
Here's my situation: there are over 100 let's say plain text DBs, each
one containing lines of different fixed-size fields format. Let's
assume lines within a single DB have same format.
</p>

<pre class="example">
# part of the record S5 db
S5EK OCSEK  00000000Z        151217999999CBF          X                                FLEX CONDITION                          0000000000000000                
S5LH OC021  00000000F        160629999999IBG CY PE08  1CPETC                        201PET IN CABIN DOG                        0003444200000000                

# part of the category 1 db
3200100030530CNNX02110000000000000000396626 NRNTR                       
3200100030531CPNX    0000000000000000396627 NRNTR                       
3200100030622UNN   110000000000000000000000                             
</pre>

<p>
So you can consider that each DB has a schema where each field is
located at a fixed offset from the beginning of the line.  We have to
provide (subset of) SQL-like operations over them<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup>, for example:
</p>

<div class="org-src-container">
<pre class="src src-sql"><span style="color: #8ac6f2; font-weight: bold;">SELECT</span> cxr,subcode,commercial_name <span style="color: #8ac6f2; font-weight: bold;">FROM</span> recordS5
<span style="color: #8ac6f2; font-weight: bold;">WHERE</span> cxr <span style="color: #8ac6f2; font-weight: bold;">LIKE</span> <span style="color: #95e454;">'LH|EK'</span>
      <span style="color: #8ac6f2; font-weight: bold;">AND</span> ((commercial_name <span style="color: #8ac6f2; font-weight: bold;">LIKE</span> <span style="color: #95e454;">'PET'</span> <span style="color: #8ac6f2; font-weight: bold;">AND</span> <span style="color: #8ac6f2; font-weight: bold;">type</span>=<span style="color: #95e454;">'C'</span>)
          <span style="color: #8ac6f2; font-weight: bold;">OR</span> (<span style="color: #8ac6f2; font-weight: bold;">type</span>=<span style="color: #95e454;">'F'</span> <span style="color: #8ac6f2; font-weight: bold;">AND</span> commercial_name=<span style="color: #95e454;">'MEAL'</span>))
      <span style="color: #8ac6f2; font-weight: bold;">AND</span> date_disc &lt; <span style="color: #95e454;">'180620'</span> <span style="color: #8ac6f2; font-weight: bold;">AND</span> date_eff &lt; date_disc

<span style="color: #8ac6f2; font-weight: bold;">SELECT</span> <span style="color: #e5786d;">COUNT</span>(*) <span style="color: #8ac6f2; font-weight: bold;">FROM</span> category1
<span style="color: #8ac6f2; font-weight: bold;">WHERE</span> age_min &lt;= 28 <span style="color: #8ac6f2; font-weight: bold;">AND</span> 28 &lt;= age_max
      <span style="color: #8ac6f2; font-weight: bold;">AND</span> (tbl_no &lt; <span style="color: #95e454;">'00050000'</span> <span style="color: #8ac6f2; font-weight: bold;">OR</span> tbl_no &gt; <span style="color: #95e454;">'01000000'</span>)
</pre>
</div>

<p>
(prompts if you guess the domain from these, also no, I've never been
affiliated with the well known Lisp company in that sector)
</p>

<p>
We'll have to iterate all DB entries, check the WHERE filter over each
line and extract information to be returned in case it passes.  These
queries can happen to run over billions of entries so we'll eye some
"systems" language, band-aids like Python are out of question.
</p>

<p>
Let's focus only on the filter condition.  WHERE is essentially a tree
where intermediate nodes are boolean operations <b>and</b>, <b>or</b> or <b>not</b>
and leaves being concrete line field operation - comparison, regular
expression matching, either with constant string or other field.
</p>


<div class="figure">
<p><img src="./where.png" alt="where.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-orgf77d741" class="outline-2">
<h2 id="orgf77d741"><span class="section-number-2">3</span> Approach I</h2>
<div class="outline-text-2" id="text-3">
<p>
So how do we go about it?  A straightforward way is to create a tree
structure instance mirroring the where clause and a matcher would
traverse this tree for each line to see if the clause is satisfied.
</p>
</div>

<div id="outline-container-orgc4bb03c" class="outline-3">
<h3 id="orgc4bb03c"><span class="section-number-3">3.1</span> WHERE tree</h3>
<div class="outline-text-3" id="text-3-1">
<p>
Can look something like:
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #8ac6f2; font-weight: bold;">struct</span> <span style="color: #92a65e; font-weight: bold;">WhereNode</span>
{
    <span style="color: #92a65e; font-weight: bold;">OperationType</span> <span style="color: #cae682;">op</span>; <span style="color: #99968b;">// </span><span style="color: #99968b;">and, or, not, regex, stringEq, stringNEq, stringLess, stringMore...</span>

    <span style="color: #99968b;">// </span><span style="color: #99968b;">not used by and/or/not nodes</span>
    <span style="color: #92a65e; font-weight: bold;">FieldId</span> <span style="color: #cae682;">field1</span>; <span style="color: #99968b;">// </span><span style="color: #99968b;">index within array with field offset and size information</span>
    <span style="color: #92a65e; font-weight: bold;">FieldId</span> <span style="color: #cae682;">field2</span>; <span style="color: #99968b;">// </span><span style="color: #99968b;">may be empty</span>
    <span style="color: #e5786d;">std</span>::<span style="color: #92a65e; font-weight: bold;">string</span> <span style="color: #cae682;">filter</span>;         <span style="color: #99968b;">// </span><span style="color: #99968b;">may not be applicable</span>

    <span style="color: #e5786d;">std</span>::<span style="color: #92a65e; font-weight: bold;">vector</span>&lt;<span style="color: #92a65e; font-weight: bold;">WhereNode</span>&gt; <span style="color: #cae682;">children</span>; <span style="color: #99968b;">// </span><span style="color: #99968b;">only and/or/not nodes have children</span>
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org551a029" class="outline-3">
<h3 id="org551a029"><span class="section-number-3">3.2</span> WHERE matcher</h3>
<div class="outline-text-3" id="text-3-2">
<p>
Traverses the WHERE tree in <a href="https://en.wikipedia.org/wiki/Depth-first">depth first</a> order and performs
<a href="https://en.wikipedia.org/wiki/Short-circuit_evaluation">short-circuit evaluation</a>:
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #92a65e; font-weight: bold;">bool</span> <span style="color: #cae682;">match</span>(<span style="color: #8ac6f2; font-weight: bold;">const</span> <span style="color: #92a65e; font-weight: bold;">char</span> *<span style="color: #cae682;">dbLine</span>, <span style="color: #8ac6f2; font-weight: bold;">const</span> <span style="color: #92a65e; font-weight: bold;">WhereNode</span> &amp;<span style="color: #cae682;">clause</span>)
{
    <span style="color: #8ac6f2; font-weight: bold;">switch</span>(clase.op)
    {
    <span style="color: #8ac6f2; font-weight: bold;">case</span> WhereAnd:
    {
        <span style="color: #8ac6f2; font-weight: bold;">for</span>(<span style="color: #8ac6f2; font-weight: bold;">const</span> <span style="color: #8ac6f2; font-weight: bold;">auto</span> &amp;<span style="color: #cae682;">child</span> : clause.children)
        {
            <span style="color: #8ac6f2; font-weight: bold;">if</span>(!match(dbLine, child))
                <span style="color: #8ac6f2; font-weight: bold;">return</span> <span style="color: #e5786d;">false</span>;
        }

        <span style="color: #8ac6f2; font-weight: bold;">return</span> <span style="color: #e5786d;">true</span>;
    }

    <span style="color: #8ac6f2; font-weight: bold;">case</span> WhereOr:
    {
        <span style="color: #8ac6f2; font-weight: bold;">for</span>(<span style="color: #8ac6f2; font-weight: bold;">const</span> <span style="color: #8ac6f2; font-weight: bold;">auto</span> &amp;<span style="color: #cae682;">child</span> : clause.children)
        {
            <span style="color: #8ac6f2; font-weight: bold;">if</span>(match(dbLine, child))
                <span style="color: #8ac6f2; font-weight: bold;">return</span> <span style="color: #e5786d;">true</span>;
        }

        <span style="color: #8ac6f2; font-weight: bold;">return</span> <span style="color: #e5786d;">false</span>;
    }

    <span style="color: #8ac6f2; font-weight: bold;">case</span> WhereNot:
    {
        assert(1 == op.children.size());
        <span style="color: #8ac6f2; font-weight: bold;">return</span> !match(dbLine, op.children.front());
    }

    <span style="color: #8ac6f2; font-weight: bold;">default</span>:                    <span style="color: #99968b;">// </span><span style="color: #99968b;">line field operation</span>
    {
        <span style="color: #8ac6f2; font-weight: bold;">return</span> applyWhereOp(dbLine, clause);
    }
    }
}
</pre>
</div>

<p>
The <b>applyWhereOp</b> procedure would switch on the operation type and
the fields/constants provided and apply some comparison operation,
regex matching, something.  Easy-peasy!
</p>

<p>
If there's one problem with the above, it would probably be that
<b>match</b> is recursive (and not in good <a href="https://en.wikipedia.org/wiki/Tail_recursion">tail-recursive</a> way) and the
compiler wouldn't be that jubilant.  There probably is a way to
linearize the WHERE tree but I'm a little concerned to think out in
depth how to conserve the short-circuiting without backtracking and
getting a headache.
</p>
</div>
</div>
</div>

<div id="outline-container-orgbdfcb19" class="outline-2">
<h2 id="orgbdfcb19"><span class="section-number-2">4</span> Approach II</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-org75f9003" class="outline-3">
<h3 id="org75f9003"><span class="section-number-3">4.1</span> Prelude</h3>
<div class="outline-text-3" id="text-4-1">
<p>
I actually didn't consider <b>Approach I</b> at all until much later, and
that for educational purposes.  Let's lay back and imagine the
following scenario from days of yore - someone comes along and
strikes:
</p>

<blockquote>
<p>
Can you extract me this and that field where such and such conditions
are met?  Like in the next hour?  Thankyouverymuch!
</p>
</blockquote>

<p>
What then, one-off program?  I bet in such case you'd write something
quick &amp; dirty, morally equivalent to:
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #92a65e; font-weight: bold;">bool</span> <span style="color: #cae682;">match</span>(<span style="color: #8ac6f2; font-weight: bold;">const</span> <span style="color: #92a65e; font-weight: bold;">char</span> *<span style="color: #cae682;">dbLine</span>)
{
    <span style="color: #8ac6f2; font-weight: bold;">const</span> <span style="color: #e5786d;">std</span>::<span style="color: #92a65e; font-weight: bold;">regex</span> <span style="color: #cae682;">cxrRegex</span>(<span style="color: #95e454;">"LH|EK"</span>);
    <span style="color: #8ac6f2; font-weight: bold;">const</span> <span style="color: #e5786d;">std</span>::<span style="color: #92a65e; font-weight: bold;">regex</span> <span style="color: #cae682;">commercialNameRegex1</span>(<span style="color: #95e454;">"PET"</span>);
    <span style="color: #8ac6f2; font-weight: bold;">const</span> <span style="color: #e5786d;">std</span>::<span style="color: #92a65e; font-weight: bold;">regex</span> <span style="color: #cae682;">commercialNameRegex2</span>(<span style="color: #95e454;">"MEAL"</span>);

    <span style="color: #8ac6f2; font-weight: bold;">return</span> (<span style="color: #e5786d;">std</span>::regex_match(dbLine + CXR_OFFSET,
                             dbLine + (CXR_OFFSET + CXR_SIZE),
                             cxrRegex)
            &amp;&amp; ((<span style="color: #e5786d;">std</span>::regex_match(dbLine + COMMERCIAL_NAME_OFFSET,
                                  dbLine + (COMMERCIAL_NAME_OFFSET + COMMERCIAL_NAME_SIZE),
                                  commercialNameRegex1)
                 &amp;&amp; dbLine[TYPE_OFFSET] == <span style="color: #95e454;">'C'</span>)
                || (dbLine[TYPE_OFFSET] == <span style="color: #95e454;">'F'</span>
                    &amp;&amp; <span style="color: #e5786d;">std</span>::regex_match(dbLine + COMMERCIAL_NAME_OFFSET,
                                        dbLine + (COMMERCIAL_NAME_OFFSET + COMMERCIAL_NAME_SIZE),
                                        commercialNameRegex2)))
            &amp;&amp; strncmp(<span style="color: #95e454;">"180620"</span>, dbLine + DATE_DISC_OFFSET, DATE_DISC_SIZE) &lt; 0
            &amp;&amp; strncmp(dbLine + DATE_EFF_OFFSET, dbLine + DATE_DISC_OFFSET, DATE_DISC_SIZE) &lt; 0);
}
</pre>
</div>

<p>
Which is about as simple and efficient (save for some clause
reordering that can be done in order to push cheaper checks earlier)
as one can get.  No recursion, no switches, no loops.  Some contrast
to the general solution!  Ignoring syntax noise, this is direct
translation of the WHERE condition.
</p>

<p>
Now imagine if on receiving a query we could temporarily pause time,
write a simple and efficient matcher tailored to the specific query
and then let it fly over the DB.  We must remember to unpause cosmic
time of course!  Only if we had such superpower.
</p>
</div>
</div>

<div id="outline-container-orgdd62685" class="outline-3">
<h3 id="orgdd62685"><span class="section-number-3">4.2</span> Embedded domain specific languages</h3>
<div class="outline-text-3" id="text-4-2">
<p>
By the way did you notice how ugly I've made the one-off thing look?
All those parenthesis, like some broken old Lisp!  We said we are
interested only in "systems" languages but let's see how we'd approach
this problem from Common Lisp's side<sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup>.
</p>

<p>
The usual thing to do is embed a <a href="https://en.wikipedia.org/wiki/Domain-specific_language">DSL</a>.  For example, we could represent
the selection thing like this:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(select (cxr subcode commercial_name) recordS5
        <span style="color: #e5786d;">:where</span> (and (like cxr <span style="color: #95e454;">"LH|EK"</span>)
                    (or (and (like COMMERCIAL_NAME <span style="color: #95e454;">"PET"</span>)
                             (= type <span style="color: #95e454;">"C"</span>))
                        (and (= type <span style="color: #95e454;">"F"</span>)
                             (like commercial_name <span style="color: #95e454;">"MEAL"</span>)))
                    (&lt; <span style="color: #95e454;">"180620"</span> date_disc)
                    (&lt; date_eff date_disc)))
</pre>
</div>

<p>
Don't know about you, but on my eyes this looks better than SQL's
supposed to be humane syntax.
</p>

<p>
So <b>select</b> could be a macro which transforms the above to a function
which goes map-reducing over the given DB and calls it.
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #8ac6f2; font-weight: bold;">defmacro</span> <span style="color: #cae682;">select</span> (field-list db <span style="color: #e5786d;">:where</span> where)
  <span style="color: #95e454;">"Generate map-reduce selection code."</span>
  <span style="color: #99968b;">;; </span><span style="color: #99968b;">...</span>
  )
</pre>
</div>
</div>
</div>

<div id="outline-container-org2233a27" class="outline-3">
<h3 id="org2233a27"><span class="section-number-3">4.3</span> WHERE tree</h3>
<div class="outline-text-3" id="text-4-3">
<p>
Let's just look at the WHERE transformation.  We can mirror the query
tree and replace some parts with "real" code:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(<span style="color: #8ac6f2; font-weight: bold;">defun</span> <span style="color: #cae682;">build-where</span> (where spec)
  <span style="color: #95e454;">"Create mirror tree for WHERE.</span>
<span style="color: #95e454;">SPEC contains fields' offset and size information."</span>
  (<span style="color: #8ac6f2; font-weight: bold;">when</span> (consp where)
    (<span style="color: #8ac6f2; font-weight: bold;">let</span> ((op (first where)))
      (cons (<span style="color: #8ac6f2; font-weight: bold;">if</span> (member op '(and or not))
                op
                (build-field-op op spec))
            (build-where (rest where) spec)))))
</pre>
</div>

<p>
Where <b>build-field-op</b> based on the field operation and fields and
constants involved and given the specification for field offsets and
sizes would generate appropriate code for particular operation.
Here's how the compiler expanded WHERE part of the code could look
like:
</p>

<div class="org-src-container">
<pre class="src src-lisp">(AND (CL-PPCRE:SCAN <span style="color: #95e454;">"LH|EK"</span> LINE <span style="color: #e5786d;">:START</span> CXR_OFFSET <span style="color: #e5786d;">:END</span> (+ CXR_OFFSET CXR_SIZE))
     (OR
      (AND (CL-PPCRE:SCAN <span style="color: #95e454;">"PET"</span> LINE <span style="color: #e5786d;">:START</span> COMMERCIAL_NAME_OFFSET
                                     <span style="color: #e5786d;">:END</span> (+ COMMERCIAL_NAME_OFFSET COMMERCIAL_NAME_SIZE))
           (CHAR= (AREF LINE TYPE_OFFSET) #\C))
      (AND
       (CHAR= (AREF LINE TYPE_OFFSET) #\F)
       (CL-PPCRE:SCAN <span style="color: #95e454;">"MEAL"</span> LINE <span style="color: #e5786d;">:START</span> COMMERCIAL_NAME_OFFSET
                                  <span style="color: #e5786d;">:END</span> (+ COMMERCIAL_NAME_OFFSET COMMERCIAL_NAME_SIZE))))
     (STRING&lt; <span style="color: #95e454;">"180620"</span> LINE <span style="color: #e5786d;">:START1</span> 0 <span style="color: #e5786d;">:END1</span> 6
                            <span style="color: #e5786d;">:START2</span> DATE_DISC_OFFSET <span style="color: #e5786d;">:END2</span> (+ DATE_DISC_OFFSET DATE_DISC_SIZE))
     (STRING&lt; LINE LINE <span style="color: #e5786d;">:START1</span> DATE_EFF_OFFSET <span style="color: #e5786d;">:END1</span> (+ DATE_EFF_OFFSET DATE_EFF_SIZE)
                        <span style="color: #e5786d;">:START2</span> DATE_DISC_OFFSET <span style="color: #e5786d;">:END2</span> (+ DATE_DISC_OFFSET DATE_DISC_SIZE)))
</pre>
</div>

<p>
That's analogical to the C++ one-off version.  With such simple,
straightforward code and a few declarations, the <a href="http://sbcl.org/">SBCL</a> compiler in
particular would be able to match a C++ compiler even skipping array
bound checks if one decides so.<sup><a id="fnr.3" class="footref" href="#fn.3">3</a></sup>
</p>
</div>
</div>
</div>

<div id="outline-container-org5cf63d7" class="outline-2">
<h2 id="org5cf63d7"><span class="section-number-2">5</span> Addendum</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-org503883b" class="outline-3">
<h3 id="org503883b"><span class="section-number-3">5.1</span> Manual JIT</h3>
<div class="outline-text-3" id="text-5-1">
<p>
Here's the essence of Approach II:
</p>


<div class="figure">
<p><img src="./arch.png" alt="arch.png" />
</p>
</div>

<p>
I like to call this tactic of plugging in Ahead-Of-Time compilation on
the fly (runtime) to assemble specialized code "Manual Just-In-Time
compilation".  Works at a higher level than <a href="https://en.wikipedia.org/wiki/Just-in-time_compilation">JIT</a> and opens
opportunities for greater (while orthogonal) gain and as seen even
algorithm simplification.  This doesn't work (at least is not
portable) for languages which leave only minimal dead skeleton of the
program for runtime like&#x2026;er, about all compiled languages.  It's
idiomatic and easy in most Lisps through macros.  Common Lisp is
especially suited with:
</p>

<ul class="org-ul">
<li>optional variable type declarations</li>
<li>compiler can be evoked at runtime (the <b>compile</b> function)</li>
<li>per function re/compilation over several dimensions and levels of optimization</li>
<li>per function disassembly</li>
<li>designed for (image based) system evolution</li>
</ul>

<p>
Some CL implementations can leverage type declarations to rival static
language <a href="https://en.wikipedia.org/wiki/Ahead-of-time_compilation">AOT</a> compilers<sup><a id="fnr.4" class="footref" href="#fn.4">4</a></sup>.  SBCL even provides hints where and why
a micro optimization couldn't be applied to guide type declaration
refinements:
</p>

<pre class="example">
source.lisp:4:3:
  note: 
    forced to do GENERIC-+ (cost 10)
          unable to do inline fixnum arithmetic (cost 2) because:
          The second argument is a NUMBER, not a FIXNUM.
          The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES FIXNUM &amp;REST T).
          unable to do inline (signed-byte 64) arithmetic (cost 5) because:
          The second argument is a NUMBER, not a (SIGNED-BYTE 64).
          The result is a (VALUES NUMBER &amp;OPTIONAL), not a (VALUES (SIGNED-BYTE 64)
                                                                   &amp;REST T).
          etc.
</pre>

<p>
Through meta-programming (where Lisps excel at) one can generate
practically static code for optimal performance.  The ability to see
how a function's disassembly changes corresponding to code adjustments
is also quite helpful and insightful.
</p>
</div>

<div id="outline-container-org9011cdd" class="outline-4">
<h4 id="org9011cdd"><span class="section-number-4">5.1.1</span> Eval?</h4>
<div class="outline-text-4" id="text-5-1-1">
<p>
I can hear you say:
</p>

<blockquote>
<p>
All those parenthesis, my eyes!  Sir, just use "modern" dynamic
language which provides <b>eval</b> function!
</p>
</blockquote>

<p>
And you'd be right with these caveats:
</p>

<ul class="org-ul">
<li>string manipulation to cover random syntax is error prone</li>
<li>it's still interpretation, not compilation (maybe some JavaScript
compiler is exception?)</li>
</ul>

<p>
In contrast to random-syntax code-is-a-string-blob languages, Lisps
deal with already parsed trees basically all the time.  Simple and
reliable to generate, traverse, transform.  DSLs become so easy to
implement, it feels like cheating.
</p>
</div>
</div>
</div>

<div id="outline-container-org71f35ef" class="outline-3">
<h3 id="org71f35ef"><span class="section-number-3">5.2</span> Alternative syntax</h3>
<div class="outline-text-3" id="text-5-2">
<p>
One may object that all falls into pieces only if we limit the user to
use <a href="https://en.wikipedia.org/wiki/S-expressions">S-expressions</a>.  What if forced to literary provide SQL syntax?
Common Lisp in particular has programmable reader (through reader
macros) which allows to make read time transformation of more funky
syntax to good ole S-expressions and keep the same approach.
</p>
</div>
</div>
</div>

<div id="outline-container-org3562ff9" class="outline-2">
<h2 id="org3562ff9"><span class="section-number-2">6</span> Further reading</h2>
<div class="outline-text-2" id="text-6">
<p>
Looking at conferences' materials, lispers (at least the Common breed)
often take advantage of such techniques<sup><a id="fnr.5" class="footref" href="#fn.5">5</a></sup> for difficult problems
but seem troubled to gain attention of the outside world.
</p>

<p>
I've been rooting for the <a href="https://medium.com/@MartinCracauer/a-gentle-introduction-to-compile-time-computing-part-1-d4d96099cea0">Gentle Introduction to Compile-Time
Computing</a> series to really launch for deeper descend into the matter
but even the outline can suggest what sort of magic is possible.
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
One may rightfully note that such data seems plain meant for SQL
storage.  There are some complications in reality including size,
performance needs and slight deviations from the fixed format why this
is not done.
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">
Although Common Lisp is dynamically typed language and everyone
"knows" all such languages are slow, CL is rare exception.  One reason
is <a href="https://en.wikipedia.org/wiki/Common_lisp">history</a>.  Lisps were the primordial wave of dynamic languages and
had to run acceptably on quite limited hardware compared to nowadays.
Lisps were crafted in ways where possibility for performance
optimizations were kept in sight and with <a href="https://en.wikipedia.org/wiki/Moore%27s_law">Moore's law</a> still
progressing - they were gradually catching up the statically typed
languages.  To the point where <a href="https://en.wikipedia.org/wiki/Genera_(operating_system)">operating systems</a> were written from the
ground up.  With Common Lisp being merger of the original line of
dialects, there are many places in its specification where freeways
for implementations to perform optimizations are present.
</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3">3</a></sup> <div class="footpara"><p class="footpara">
In fact, in the same vein the <b>cl-ppcre</b> library goes a step
further (than usual compiled languages) to build regex scanners for
the literals at compile time thanks to (read time) compiler macro.
</p></div></div>

<div class="footdef"><sup><a id="fn.4" class="footnum" href="#fnr.4">4</a></sup> <div class="footpara"><p class="footpara">
<a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/which-programs-are-fast.html">https://benchmarksgame-team.pages.debian.net/benchmarksgame/which-programs-are-fast.html</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.5" class="footnum" href="#fnr.5">5</a></sup> <div class="footpara"><p class="footpara">
Like <a href="https://european-lisp-symposium.org/static/2018/heisig.pdf">Petalisp - A Common Lisp Library for Data Parallel Programming</a>
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<p class="author">Author: Andrey Kotlarski</p>
<p class="date">Created: 2018-07-31 вт 04:41</p>
<p class="creator"><a href="https://www.gnu.org/software/emacs/">Emacs</a> 26.1 (<a href="https://orgmode.org">Org</a> mode 9.1.9)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
